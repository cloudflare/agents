<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HTTP Reusable Chat Example</title>
    <style>
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }

      .container {
        background: white;
        border-radius: 12px;
        padding: 24px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
      }

      h1 {
        color: #333;
        margin-bottom: 8px;
      }

      .subtitle {
        color: #666;
        margin-bottom: 24px;
        font-size: 14px;
      }

      .chat-container {
        border: 1px solid #e1e5e9;
        border-radius: 8px;
        height: 400px;
        overflow-y: auto;
        padding: 16px;
        margin-bottom: 16px;
        background: #fafbfc;
      }

      .message {
        margin-bottom: 16px;
        padding: 12px;
        border-radius: 8px;
        max-width: 80%;
      }

      .message.user {
        background: #007bff;
        color: white;
        margin-left: auto;
      }

      .message.assistant {
        background: #e9ecef;
        color: #333;
      }

      .message.system {
        background: #fff3cd;
        color: #856404;
        font-style: italic;
        max-width: 100%;
        text-align: center;
      }

      .input-container {
        display: flex;
        gap: 8px;
        margin-bottom: 16px;
      }

      input[type="text"] {
        flex: 1;
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 14px;
      }

      button {
        padding: 12px 20px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
      }

      button:hover {
        background: #0056b3;
      }

      button:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      .controls {
        display: flex;
        gap: 8px;
        margin-bottom: 16px;
        flex-wrap: wrap;
      }

      .stream-info {
        background: #d1ecf1;
        border: 1px solid #bee5eb;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 16px;
        font-size: 14px;
      }

      .stream-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px;
        background: white;
        border-radius: 4px;
        margin-bottom: 8px;
      }

      .stream-item:last-child {
        margin-bottom: 0;
      }

      .stream-actions {
        display: flex;
        gap: 4px;
      }

      .stream-actions button {
        padding: 4px 8px;
        font-size: 12px;
      }

      .loading {
        opacity: 0.7;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>HTTP Reusable Chat Example</h1>
      <p class="subtitle">
        Testing HTTP-based chat with resumable streams (no WebSockets)
      </p>

      <div class="controls">
        <button onclick="clearHistory()">Clear History</button>
        <button onclick="refreshMessages()">Refresh Messages</button>
        <button onclick="testLongStory()">Test Long Story</button>
      </div>

      <div id="streamInfo" class="stream-info" style="display: none">
        <strong>Active Streams:</strong>
        <div id="streamList"></div>
      </div>

      <div id="chatContainer" class="chat-container"></div>

      <div class="input-container">
        <input
          type="text"
          id="messageInput"
          placeholder="Type your message..."
          onkeypress="handleKeyPress(event)"
        />
        <button onclick="sendMessage()" id="sendButton">Send</button>
      </div>
    </div>

    <script>
      const AGENT_URL = "http://localhost:5175/HttpChatAgent/http-chat";
      let messages = [];
      let activeStreams = [];
      let pollingInterval = null;

      // Initialize
      document.addEventListener("DOMContentLoaded", () => {
        loadMessages();
        startPolling();
      });

      async function loadMessages() {
        try {
          const response = await fetch(`${AGENT_URL}/messages`);
          if (response.ok) {
            const data = await response.json();
            messages = data.messages || [];
            renderMessages();
          }
        } catch (error) {
          console.error("Failed to load messages:", error);
          addSystemMessage("Failed to load message history");
        }
      }

      async function sendMessage() {
        const input = document.getElementById("messageInput");
        const message = input.value.trim();

        if (!message) return;

        const sendButton = document.getElementById("sendButton");
        sendButton.disabled = true;
        sendButton.textContent = "Sending...";

        // Add user message to UI immediately
        const userMessage = {
          id: `user_${Date.now()}`,
          role: "user",
          parts: [{ type: "text", text: message }]
        };

        messages.push(userMessage);
        renderMessages();
        input.value = "";

        try {
          const response = await fetch(`${AGENT_URL}/chat`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              messages: [...messages]
            })
          });

          if (response.ok) {
            const streamId = response.headers.get("X-Stream-Id");
            if (streamId) {
              activeStreams.push({
                streamId,
                position: 0,
                completed: false,
                lastUpdate: Date.now()
              });
              updateStreamInfo();
            }

            // Process streaming response
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let assistantMessage = {
              id: `assistant_${Date.now()}`,
              role: "assistant",
              parts: [{ type: "text", text: "" }]
            };

            messages.push(assistantMessage);

            while (true) {
              const { done, value } = await reader.read();
              if (done) break;

              const chunk = decoder.decode(value);
              const lines = chunk.split("\n");

              for (const line of lines) {
                if (line.startsWith("data: ") && line !== "data: [DONE]") {
                  try {
                    const data = JSON.parse(line.slice(6));
                    if (data.type === "text-delta" && data.delta) {
                      assistantMessage.parts[0].text += data.delta;
                      renderMessages();
                    }
                  } catch (e) {
                    // Skip malformed JSON
                  }
                }
              }
            }

            // Mark stream as completed
            if (streamId) {
              activeStreams = activeStreams.map((s) =>
                s.streamId === streamId ? { ...s, completed: true } : s
              );
              updateStreamInfo();
            }
          } else {
            addSystemMessage(
              `Error: ${response.status} ${response.statusText}`
            );
          }
        } catch (error) {
          console.error("Send message error:", error);
          addSystemMessage(`Failed to send message: ${error.message}`);
        } finally {
          sendButton.disabled = false;
          sendButton.textContent = "Send";
        }
      }

      function renderMessages() {
        const container = document.getElementById("chatContainer");
        container.innerHTML = "";

        messages.forEach((message) => {
          const messageDiv = document.createElement("div");
          messageDiv.className = `message ${message.role}`;

          const textPart = message.parts?.find((p) => p.type === "text");
          messageDiv.textContent = textPart?.text || "[No content]";

          container.appendChild(messageDiv);
        });

        container.scrollTop = container.scrollHeight;
      }

      function addSystemMessage(text) {
        const systemMessage = {
          id: `system_${Date.now()}`,
          role: "system",
          parts: [{ type: "text", text }]
        };
        messages.push(systemMessage);
        renderMessages();
      }

      async function clearHistory() {
        try {
          const response = await fetch(`${AGENT_URL}/messages`, {
            method: "DELETE"
          });

          if (response.ok) {
            messages = [];
            activeStreams = [];
            renderMessages();
            updateStreamInfo();
            addSystemMessage("Chat history cleared");
          } else {
            addSystemMessage("Failed to clear history");
          }
        } catch (error) {
          console.error("Clear history error:", error);
          addSystemMessage("Failed to clear history");
        }
      }

      async function refreshMessages() {
        await loadMessages();
        addSystemMessage("Messages refreshed");
      }

      function testLongStory() {
        document.getElementById("messageInput").value =
          "Tell me a very long and detailed story about a magical forest. Make it at least 500 words with multiple paragraphs.";
      }

      function handleKeyPress(event) {
        if (event.key === "Enter") {
          sendMessage();
        }
      }

      async function resumeStream(streamId) {
        try {
          const response = await fetch(`${AGENT_URL}/stream/${streamId}`);
          if (response.ok) {
            const content = await response.text();
            addSystemMessage(
              `Resumed stream ${streamId}: ${content.substring(0, 100)}...`
            );
          }
        } catch (error) {
          console.error("Resume stream error:", error);
          addSystemMessage(`Failed to resume stream ${streamId}`);
        }
      }

      async function cancelStream(streamId) {
        try {
          const response = await fetch(
            `${AGENT_URL}/stream/${streamId}/cancel`,
            {
              method: "POST"
            }
          );

          if (response.ok) {
            activeStreams = activeStreams.filter(
              (s) => s.streamId !== streamId
            );
            updateStreamInfo();
            addSystemMessage(`Cancelled stream ${streamId}`);
          }
        } catch (error) {
          console.error("Cancel stream error:", error);
          addSystemMessage(`Failed to cancel stream ${streamId}`);
        }
      }

      function updateStreamInfo() {
        const streamInfo = document.getElementById("streamInfo");
        const streamList = document.getElementById("streamList");

        if (activeStreams.length === 0) {
          streamInfo.style.display = "none";
          return;
        }

        streamInfo.style.display = "block";
        streamList.innerHTML = "";

        activeStreams.forEach((stream) => {
          const streamDiv = document.createElement("div");
          streamDiv.className = "stream-item";
          streamDiv.innerHTML = `
                    <span>Stream ${stream.streamId.substring(0, 8)}... (${stream.completed ? "Completed" : "Active"})</span>
                    <div class="stream-actions">
                        <button onclick="resumeStream('${stream.streamId}')">Resume</button>
                        <button onclick="cancelStream('${stream.streamId}')">Cancel</button>
                    </div>
                `;
          streamList.appendChild(streamDiv);
        });
      }

      function startPolling() {
        if (pollingInterval) return;

        pollingInterval = setInterval(async () => {
          // Check for message updates
          try {
            const response = await fetch(`${AGENT_URL}/messages`);
            if (response.ok) {
              const data = await response.json();
              const serverMessages = data.messages || [];

              if (JSON.stringify(serverMessages) !== JSON.stringify(messages)) {
                messages = serverMessages;
                renderMessages();
              }
            }
          } catch (error) {
            console.warn("Polling error:", error);
          }

          // Check stream statuses
          if (activeStreams.length > 0) {
            const updatedStreams = await Promise.all(
              activeStreams.map(async (stream) => {
                try {
                  const response = await fetch(
                    `${AGENT_URL}/stream/${stream.streamId}/status`
                  );
                  if (response.ok) {
                    const status = await response.json();
                    return {
                      ...stream,
                      position: status.position,
                      completed: status.completed,
                      lastUpdate: Date.now()
                    };
                  }
                } catch (error) {
                  console.warn(
                    `Failed to check stream ${stream.streamId}:`,
                    error
                  );
                }
                return stream;
              })
            );

            activeStreams = updatedStreams.filter((s) => !s.completed);
            updateStreamInfo();
          }
        }, 2000); // Poll every 2 seconds
      }

      // Cleanup on page unload
      window.addEventListener("beforeunload", () => {
        if (pollingInterval) {
          clearInterval(pollingInterval);
        }
      });
    </script>
  </body>
</html>
