<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Agent Dashboard</title>

    <!-- External Libraries -->
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <link
      href="https://unpkg.com/cytoscape-navigator@3.0.0/cytoscape.js-navigator.css"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/cytoscape-navigator@3.0.0/cytoscape-navigator.js"></script>
    <script src="https://unpkg.com/reconnecting-websocket@4.4.0/dist/reconnecting-websocket-iife.min.js"></script>
    <link
      href="https://unpkg.com/prismjs@1.29.0/themes/prism-okaidia.min.css"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/prismjs@1.29.0/prism.min.js"></script>
    <script>
      // Load Prism language components after main library is ready
      if (typeof Prism !== "undefined") {
        const languages = [
          "json",
          "javascript",
          "typescript",
          "python",
          "markdown"
        ];
        languages.forEach((lang) => {
          const script = document.createElement("script");
          script.src = `https://unpkg.com/prismjs@1.29.0/components/prism-${lang}.min.js`;
          document.head.appendChild(script);
        });
      }
    </script>
    <script src="https://unpkg.com/dayjs@1.11.10/dayjs.min.js"></script>
    <script src="https://unpkg.com/dayjs@1.11.10/plugin/relativeTime.js"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/notyf@3.10.0/notyf.min.css"
    />
    <script src="https://unpkg.com/notyf@3.10.0/notyf.min.js"></script>
    <script src="https://unpkg.com/ky@1.2.3/distribution/index.umd.js"></script>
    <script src="https://unpkg.com/markdown-it@14.0.0/dist/markdown-it.min.js"></script>

    <style>
      :root {
        --bg: #050608;
        --surface: rgba(10, 14, 22, 0.92);
        --surface-alt: rgba(13, 18, 29, 0.85);
        --fg: #f5f7fa;
        --muted: #9da5ba;
        --accent: #f97316;
        --accent-soft: rgba(249, 115, 22, 0.14);
        --border: rgba(255, 255, 255, 0.1);
        --border-strong: rgba(249, 115, 22, 0.4);
        --ok: #22c55e;
        --warn: #facc15;
        --err: #ef4444;
        --info: #60a5fa;
        --tool: #c084fc;
        --model: #34d399;
        --pause: #fb923c;
      }

      body {
        font:
          14px "Inter",
          system-ui,
          sans-serif;
        margin: 0;
        padding: 0;
        color: var(--fg);
        background-color: #0b101c;
        background-image:
          radial-gradient(rgba(255, 255, 255, 0.04) 1px, transparent 0),
          radial-gradient(rgba(255, 255, 255, 0.025) 1px, transparent 0);
        background-size:
          28px 28px,
          12px 12px;
        background-position:
          0 0,
          14px 14px;
        min-height: 100vh;
      }

      ::selection {
        background: var(--accent);
        color: #0b0e1a;
      }

      .container {
        box-sizing: border-box;
        width: 100%;
        max-width: none;
        margin: 0;
        padding: 28px 36px 60px;
      }

      .dashboard {
        display: grid;
        grid-template-columns: 260px minmax(0, 1fr);
        gap: 24px;
        align-items: flex-start;
      }

      .sidebar {
        display: flex;
        flex-direction: column;
        min-height: calc(100vh - 180px);
        gap: 16px;
      }

      .sidebar-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 12px;
      }

      .sidebar-header h3 {
        margin: 0;
        font-size: 18px;
        letter-spacing: 0.02em;
      }

      .sidebar-header p {
        margin: 6px 0 0;
        color: var(--muted);
        font-size: 12px;
      }

      .sidebar-actions {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .thread-row {
        display: block;
      }
      .thread-row.expanded > .thread-children {
        display: block;
      }

      .thread-children {
        display: none;
        margin-left: 8px;
        padding-left: 10px;
        border-left: 1px dashed var(--border);
      }

      .threads-list {
        flex: 1;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding-right: 4px;
      }

      .thread-item {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
        padding: 12px 14px;
        padding-left: calc(12px + (var(--depth, 0) * 16px));
        border-radius: 8px;
        border: 1px dashed transparent;
        background: rgba(255, 255, 255, 0.02);
        color: var(--fg);
        text-align: left;
        cursor: pointer;
        transition:
          background 0.2s ease,
          border 0.2s ease,
          transform 0.2s;
        font-size: calc(14px - (var(--depth, 0) * 0.5px));
        transform-origin: left center;
      }

      .thread-item[data-depth]:not([data-depth="0"]) {
        transform: scale(0.98);
        opacity: 0.95;
      }

      .thread-item:hover {
        background: rgba(249, 115, 22, 0.08);
        border-color: var(--border);
        transform: translateX(2px);
      }

      .thread-item.active {
        border-color: var(--accent);
        background: rgba(249, 115, 22, 0.16);
      }

      .thread-title {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .thread-caret {
        display: inline-flex;
        width: 16px;
        height: 16px;
        align-items: center;
        justify-content: center;
        margin-right: 2px;
        opacity: 0.85;
        border-radius: 3px;
        user-select: none;
      }
      .thread-item.has-children .thread-caret {
        cursor: pointer;
      }

      .thread-meta {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        color: var(--muted);
        font-size: 12px;
      }

      .thread-prefix {
        font-family: "JetBrains Mono", Consolas, monospace;
        font-size: 11px;
        color: var(--muted);
        white-space: pre;
        display: inline-block;
        min-width: 3ch;
        text-align: right;
        margin-right: 6px;
        opacity: 0.8;
      }

      .thread-root-dot {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 2.5ch;
        font-size: 11px;
        color: var(--accent);
        margin-right: 6px;
      }

      .threads-empty {
        text-align: center;
        padding: 24px 14px;
        border-radius: 8px;
        border: 1px dashed var(--border);
        background: rgba(255, 255, 255, 0.02);
        color: var(--muted);
        font-size: 13px;
      }

      .main-area {
        display: flex;
        flex-direction: column;
        gap: 20px;
        min-width: 0;
      }

      .view-tabs {
        display: flex;
        gap: 10px;
      }

      .view-tab {
        flex: 1;
        padding: 10px 14px;
        border-radius: 6px;
        border: 1px dashed transparent;
        background: rgba(255, 255, 255, 0.04);
        color: var(--muted);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }

      .view-tab.active {
        color: var(--fg);
        border-color: var(--border-strong);
        background: rgba(249, 115, 22, 0.14);
      }

      .view-section {
        display: none;
        flex-direction: column;
        gap: 20px;
      }

      .view-section.active {
        display: flex;
      }

      .view-chat-main {
        display: flex;
        gap: 20px;
        align-items: stretch;
        flex-wrap: nowrap;
      }

      .view-chat-main .chat-card {
        flex: 1;
      }

      .todos-column {
        flex: 0 0 260px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .todos-column .todos-card {
        flex: 1;
      }

      .state-card {
        margin-top: 8px;
      }

      .chat-card {
        grid-area: chat;
        display: flex;
        flex-direction: column;
        gap: 20px;
        min-height: 580px;
        max-height: 1000px;
      }

      .chat-header {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: flex-end;
      }

      .chat-header .input-group {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .chat-header label {
        font-size: 13px;
        color: var(--muted);
        letter-spacing: 0.04em;
      }

      .run-summary {
        margin-top: 16px;
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }

      .run-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 12px;
        border-radius: 999px;
        border: 1px dashed var(--border);
        background: rgba(255, 255, 255, 0.04);
        font-size: 12px;
        font-weight: 600;
        text-transform: capitalize;
      }

      .run-badge.running {
        color: var(--accent);
        border-color: var(--border-strong);
        background: var(--accent-soft);
      }

      .run-badge.paused {
        color: var(--pause);
        border-color: rgba(251, 146, 60, 0.35);
        background: rgba(251, 146, 60, 0.15);
      }

      .run-badge.completed {
        color: var(--ok);
        border-color: rgba(34, 197, 94, 0.35);
        background: rgba(34, 197, 94, 0.18);
      }

      .run-badge.error {
        color: var(--err);
        border-color: rgba(239, 68, 68, 0.4);
        background: rgba(239, 68, 68, 0.18);
      }

      .run-meta {
        font-size: 13px;
        color: var(--muted);
      }

      .chat-transcript {
        background: var(--surface-alt);
        border: 1px dashed var(--border);
        border-radius: 6px;
        padding: 18px;
        margin-top: 16px;
        min-height: 360px;
        max-height: none;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .chat-empty {
        text-align: center;
        color: var(--muted);
        padding: 48px 0;
      }

      .chat-message {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 14px 16px;
        border-radius: 8px;
        border: 1px dashed rgba(255, 255, 255, 0.08);
        max-width: 70%;
        background: rgba(255, 255, 255, 0.02);
      }

      .chat-message.user {
        align-self: flex-end;
        background: rgba(249, 115, 22, 0.2);
        border-color: rgba(249, 115, 22, 0.5);
        color: #fff7ed;
      }

      .chat-message.assistant {
        align-self: flex-start;
        background: rgba(34, 197, 94, 0.18);
        border-color: rgba(34, 197, 94, 0.45);
      }

      .chat-message.tool {
        align-self: flex-start;
        background: rgba(192, 132, 252, 0.16);
        border-color: rgba(192, 132, 252, 0.45);
      }

      .chat-role {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: var(--muted);
      }

      .chat-content {
        font-size: 14px;
        line-height: 1.6;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .tool-call {
        margin-top: 10px;
        border: 1px dashed rgba(255, 255, 255, 0.18);
        border-radius: 6px;
        background: rgba(6, 10, 18, 0.92);
        font-family: "JetBrains Mono", Consolas, monospace;
        font-size: 12px;
        overflow: hidden;
      }

      .tool-call.collapsed .tool-call-body {
        display: none;
      }

      .tool-call-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 10px 12px;
      }

      .tool-call-title {
        font-weight: 600;
        color: var(--fg);
      }

      .tool-call-toggle {
        border: 1px dashed rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.06);
        color: var(--muted);
        font-family: inherit;
        font-size: 12px;
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .tool-call-toggle:hover {
        background: rgba(249, 115, 22, 0.16);
        color: var(--fg);
      }

      .tool-call-body {
        padding: 0 12px 12px;
        max-height: 420px;
        overflow: auto;
      }

      .chat-input {
        margin-top: 16px;
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .chat-input textarea {
        flex: 1;
        min-height: 80px;
      }

      .chat-actions {
        margin-top: 12px;
        display: flex;
        justify-content: flex-end;
      }

      .shortcuts-hint {
        font-size: 12px;
        color: var(--muted);
      }

      .shortcut {
        display: inline-block;
        padding: 2px 6px;
        background: rgba(255, 255, 255, 0.08);
        border-radius: 4px;
        font-family: monospace;
        margin: 0 2px;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 1px dashed var(--border);
      }

      .header h1 {
        margin: 0;
        font-size: 26px;
        font-weight: 600;
        letter-spacing: 0.04em;
        color: var(--fg);
      }

      .status-bar {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .status-indicator {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        border: 1px dashed var(--border);
        background: rgba(255, 255, 255, 0.03);
      }

      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
      }

      .status-indicator.connected {
        color: var(--ok);
        border-color: rgba(34, 197, 94, 0.4);
      }
      .status-indicator.connected .status-dot {
        background-color: var(--ok);
      }
      .status-indicator.disconnected {
        color: var(--err);
        border-color: rgba(239, 68, 68, 0.4);
      }
      .status-indicator.disconnected .status-dot {
        background-color: var(--err);
      }

      .card {
        background: var(--surface);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 16px;
        backdrop-filter: blur(12px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        border: 1px dashed var(--border);
      }

      textarea,
      input {
        box-sizing: border-box;
        width: 100%;
        padding: 10px 12px;
        border-radius: 6px;
        border: 1px dashed rgba(255, 255, 255, 0.12);
        background: rgba(6, 10, 18, 0.9);
        color: var(--fg);
        font-family: inherit;
      }

      textarea:focus,
      input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(249, 115, 22, 0.25);
      }

      pre {
        background: rgba(6, 10, 18, 0.9);
        color: var(--fg);
        padding: 16px;
        border-radius: 6px;
        max-height: 500px;
        overflow: auto;
        word-wrap: break-word;
        white-space: pre-wrap;
        border: 1px dashed var(--border);
        font-family: "JetBrains Mono", Consolas, monospace;
        font-size: 12px;
      }

      button {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px dashed var(--border);
        background: rgba(255, 255, 255, 0.04);
        color: var(--fg);
        cursor: pointer;
        transition:
          background 0.2s ease,
          transform 0.2s ease,
          border-color 0.2s ease;
      }

      button:hover {
        background: rgba(255, 255, 255, 0.1);
        transform: translateY(-1px);
      }

      button:active {
        transform: translateY(0);
      }

      button.primary {
        background: var(--accent);
        color: #050608;
        border-color: var(--border-strong);
      }

      button.primary:hover {
        background: #fb8f3c;
      }

      button.danger {
        background: rgba(239, 68, 68, 0.15);
        color: #fecaca;
        border-color: rgba(239, 68, 68, 0.45);
      }

      button.danger:hover {
        background: rgba(239, 68, 68, 0.3);
      }

      .button-group {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      code {
        white-space: pre-wrap;
        font-family: "JetBrains Mono", Consolas, monospace;
      }

      /* Graph area */
      .threadline-card {
        grid-area: thread;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .threadline-header {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        color: var(--muted);
        font-size: 12px;
      }

      .threadline-header .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px dashed var(--border);
        background: rgba(255, 255, 255, 0.03);
      }

      .threadline-badge-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: inline-block;
      }

      .graph-wrap {
        position: relative;
        border: 1px dashed var(--border);
        border-radius: 6px;
        padding: 0;
        background:
          radial-gradient(rgba(255, 255, 255, 0.04) 1px, transparent 0),
          linear-gradient(160deg, rgba(10, 14, 22, 0.85), rgba(13, 18, 29, 0.9));
        background-size:
          20px 20px,
          100% 100%;
        overflow: hidden;
        height: calc(90vh - 150px);
      }

      #graph {
        display: block;
        width: 100%;
        height: 100%;
        user-select: none;
        -webkit-user-select: none;
      }

      /* Cytoscape navigator (minimap) styles */
      .cytoscape-navigator {
        position: absolute;
        bottom: 60px;
        right: 14px;
        width: 200px;
        height: 150px;
        border: 1px dashed var(--border);
        border-radius: 6px;
        background: rgba(10, 14, 22, 0.92);
        backdrop-filter: blur(8px);
        overflow: hidden;
      }

      .laneLabel {
        font:
          11px "Inter",
          system-ui,
          sans-serif;
        fill: var(--muted);
        font-weight: 600;
        letter-spacing: 0.06em;
      }

      .node-circle {
        cursor: pointer;
        transition: opacity 0.2s;
      }

      .node-circle:hover {
        opacity: 1 !important;
      }

      .lane-label-card {
        fill: rgba(8, 12, 20, 0.88);
        stroke: rgba(255, 255, 255, 0.14);
        stroke-dasharray: 4 4;
      }

      .lane-label-title {
        font:
          12px "Inter",
          system-ui,
          sans-serif;
        fill: var(--fg);
        font-weight: 600;
      }

      .lane-label-meta {
        font:
          11px "Inter",
          system-ui,
          sans-serif;
        fill: var(--muted);
        letter-spacing: 0.04em;
      }

      /* Modal */
      .modal {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.78);
        z-index: 1000;
        align-items: center;
        justify-content: center;
      }
      .modal.open {
        display: flex;
      }
      .modal-content {
        background: linear-gradient(
          135deg,
          rgba(18, 26, 42, 0.95) 0%,
          rgba(6, 10, 18, 0.98) 100%
        );
        color: var(--fg);
        padding: 24px;
        border-radius: 8px;
        max-width: 760px;
        max-height: 80vh;
        overflow: auto;
        position: relative;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
        border: 1px dashed var(--border);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px dashed var(--border);
      }
      .modal-title {
        margin: 0;
        font-size: 18px;
        color: var(--accent);
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .modal-close {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        border: none;
        border-radius: 6px;
        padding: 6px 12px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.2s;
      }
      .modal-close:hover {
        background: rgba(255, 255, 255, 0.2);
      }
      .modal-json {
        background: rgba(6, 10, 18, 0.92);
        padding: 16px;
        border-radius: 6px;
        overflow: auto;
        max-height: 520px;
        font:
          12px "JetBrains Mono",
          monospace;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        border: 1px dashed var(--border);
      }

      .zoom-controls {
        position: absolute;
        bottom: 14px;
        right: 14px;
        display: flex;
        gap: 8px;
        align-items: center;
        background: rgba(10, 14, 22, 0.82);
        border: 1px dashed var(--border);
        padding: 6px 8px;
        border-radius: 6px;
        backdrop-filter: blur(8px);
      }
      .zoom-controls button {
        padding: 4px 10px;
      }
      .zoom-controls .zoom-pct {
        min-width: 52px;
        text-align: center;
        font-weight: 600;
        color: var(--muted);
      }

      .todos-card,
      .files-card {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .todos-summary {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin: 8px 0 12px;
        color: var(--muted);
        font-size: 12px;
      }
      .todo-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px dashed var(--border);
        background: rgba(255, 255, 255, 0.03);
        font-weight: 600;
      }
      .todo-pill.pending {
        color: #a5b1c2;
      }
      .todo-pill.in_progress {
        color: var(--info);
      }
      .todo-pill.completed {
        color: var(--ok);
      }

      .todo-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .todo-item {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        padding: 10px 12px;
        border: 1px dashed var(--border);
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.02);
      }
      .todo-status {
        min-width: 8px;
        min-height: 8px;
        border-radius: 999px;
        margin-top: 6px;
      }
      .todo-status.pending {
        background: #9ca3af;
      }
      .todo-status.in_progress {
        background: var(--info);
      }
      .todo-status.completed {
        background: var(--ok);
      }
      .todo-content {
        word-break: break-word;
        font-size: 13px;
      }

      .files-panel {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .files-list {
        border: 1px dashed var(--border);
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.02);
        overflow: auto;
        max-height: 420px;
      }
      .file-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 12px;
        cursor: pointer;
        border-bottom: 1px dashed rgba(255, 255, 255, 0.06);
      }
      .file-row:last-child {
        border-bottom: none;
      }
      .file-row:hover {
        background: rgba(249, 115, 22, 0.08);
      }
      .file-name {
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 180px;
      }
      .file-meta {
        font-size: 12px;
        color: var(--muted);
      }
      .file-preview {
        background: rgba(6, 10, 18, 0.9);
        padding: 12px;
        border: 1px dashed var(--border);
        border-radius: 6px;
        max-height: 65vh;
        overflow: auto;
      }

      /* Markdown rendering styles in file preview */
      .file-preview h1,
      .file-preview h2,
      .file-preview h3 {
        color: var(--accent);
        margin-top: 1.5em;
        margin-bottom: 0.5em;
      }
      .file-preview h1 {
        font-size: 1.8em;
        border-bottom: 2px solid var(--border);
        padding-bottom: 0.3em;
      }
      .file-preview h2 {
        font-size: 1.5em;
        border-bottom: 1px solid var(--border);
        padding-bottom: 0.3em;
      }
      .file-preview h3 {
        font-size: 1.2em;
      }
      .file-preview p {
        margin: 1em 0;
      }
      .file-preview a {
        color: var(--info);
        text-decoration: none;
      }
      .file-preview a:hover {
        text-decoration: underline;
      }
      .file-preview code {
        background: rgba(255, 255, 255, 0.1);
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.9em;
      }
      .file-preview pre {
        background: rgba(0, 0, 0, 0.4);
        padding: 12px;
        border-radius: 6px;
        overflow-x: auto;
        margin: 1em 0;
      }
      .file-preview pre code {
        background: none;
        padding: 0;
      }
      .file-preview ul,
      .file-preview ol {
        margin: 1em 0;
        padding-left: 2em;
      }
      .file-preview li {
        margin: 0.5em 0;
      }
      .file-preview blockquote {
        border-left: 4px solid var(--accent);
        padding-left: 1em;
        margin: 1em 0;
        color: var(--muted);
      }
      .file-preview table {
        border-collapse: collapse;
        width: 100%;
        margin: 1em 0;
      }
      .file-preview th,
      .file-preview td {
        border: 1px solid var(--border);
        padding: 8px 12px;
        text-align: left;
      }
      .file-preview th {
        background: rgba(255, 255, 255, 0.05);
        font-weight: 600;
      }

      /* line numbers in preview */
      .ln {
        color: #5f6a87;
        user-select: none;
        margin-right: 10px;
        display: inline-block;
        width: 48px;
        text-align: right;
      }
      .code {
        white-space: pre;
        font-size: 12px;
      }

      .state-card {
        grid-area: state;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .notification {
        position: fixed;
        bottom: 24px;
        right: 24px;
        padding: 12px 16px;
        border-radius: 6px;
        color: white;
        font-weight: 600;
        box-shadow: 0 12px 34px rgba(0, 0, 0, 0.3);
        z-index: 2000;
        opacity: 1;
        transition: opacity 0.3s ease;
      }

      .notification.success {
        background: var(--ok);
      }

      .notification.error {
        background: var(--err);
      }

      .notification.info {
        background: var(--info);
      }
      .status-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px dashed var(--border);
        background: rgba(255, 255, 255, 0.03);
        font-size: 11px;
        font-weight: 700;
      }

      .status-pill.s-running {
        color: var(--accent);
        border-color: var(--border-strong);
        background: var(--accent-soft);
      }
      .status-pill.s-completed {
        color: var(--ok);
        border-color: rgba(34, 197, 94, 0.35);
        background: rgba(34, 197, 94, 0.18);
      }
      .status-pill.s-paused {
        color: var(--pause);
        border-color: rgba(251, 146, 60, 0.35);
        background: rgba(251, 146, 60, 0.15);
      }
      .status-pill.s-error {
        color: var(--err);
        border-color: rgba(239, 68, 68, 0.4);
        background: rgba(239, 68, 68, 0.18);
      }
      .status-pill.s-listening {
        color: var(--info);
        border-color: rgba(96, 165, 250, 0.35);
        background: rgba(96, 165, 250, 0.16);
      }
      .status-pill.s-offline {
        color: var(--muted);
        background: rgba(255, 255, 255, 0.02);
      }
      .form-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 20px;
      }

      .form-group label {
        font-size: 12px;
        color: var(--muted);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .form-select {
        appearance: none;
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%239da5ba%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
        background-repeat: no-repeat;
        background-position: right 0.7em top 50%;
        background-size: 0.65em auto;
        cursor: pointer;
        width: 100%;
        padding-top: 10px;
        padding-right: 2em;
        padding-bottom: 10px;
        padding-left: 12px;
        border-radius: 6px;
        border: 1px dashed rgba(255, 255, 255, 0.12);
        background-color: rgba(6, 10, 18, 0.9);
        color: var(--fg);
        font-family: inherit;
      }

      .agent-desc-preview {
        font-size: 13px;
        color: var(--muted);
        padding: 12px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 6px;
        border: 1px dashed var(--border);
        min-height: 40px;
        line-height: 1.4;
      }

      /* Blueprint card hover effect */
      .blueprint-card {
        transition:
          border-color 0.2s ease,
          background 0.2s ease;
      }
      .blueprint-card:hover {
        border-color: var(--accent) !important;
        background: rgba(249, 115, 22, 0.05) !important;
      }

      /* Improved form inputs */
      .form-group textarea {
        resize: vertical;
        min-height: 80px;
      }

      /* Modal backdrop animation */
      .modal {
        transition: opacity 0.2s ease;
        opacity: 0;
        pointer-events: none;
      }
      .modal.open {
        opacity: 1;
        pointer-events: auto;
      }

      /* Graph node glow effect */
      .cy-node-glow {
        box-shadow: 0 0 20px currentColor;
      }

      @media (max-width: 1280px) {
        .dashboard {
          grid-template-columns: 1fr;
        }

        .sidebar {
          min-height: auto;
        }
      }

      @media (max-width: 1024px) {
        .view-tabs {
          flex-direction: column;
        }

        .view-tab {
          width: 100%;
        }

        .view-chat-main {
          flex-direction: column;
        }

        .todos-column {
          flex: 1 1 auto;
        }
      }

      @media (max-width: 768px) {
        .container {
          padding: 20px 16px 40px;
        }

        .chat-card {
          min-height: 420px;
        }

        .graph-wrap {
          height: 420px;
        }

        .modal-content {
          max-width: 90%;
          padding: 18px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Agent Dashboard</h1>
        <div class="status-bar">
          <div id="connectionStatus" class="status-indicator disconnected">
            <span class="status-dot"></span>
            <span>Disconnected</span>
          </div>
        </div>
      </div>

      <div class="dashboard">
        <aside
          class="card sidebar"
          role="complementary"
          aria-label="Agent management sidebar"
        >
          <div class="sidebar-header">
            <div style="flex: 1">
              <h3>Agents</h3>
              <p>Control Plane</p>
              <select
                id="agencySelect"
                aria-label="Select agency"
                style="
                  width: 100%;
                  margin-top: 8px;
                  padding: 4px;
                  background: rgba(255, 255, 255, 0.1);
                  color: white;
                  border: 1px solid rgba(255, 255, 255, 0.2);
                  border-radius: 4px;
                "
              >
                <option value="" disabled selected>Select Agency...</option>
              </select>
            </div>
            <div class="sidebar-actions">
              <button
                id="btnNewAgency"
                title="New Agency"
                aria-label="Create new agency"
              >
                +
              </button>
              <button
                id="btnBlueprints"
                title="Manage Blueprints"
                aria-label="Manage agent blueprints"
                style="font-size: 12px"
              >
                ðŸ§¬
              </button>
              <button
                id="btnNewThread"
                title="New Thread"
                aria-label="Create new thread"
              >
                New
              </button>
            </div>
          </div>
          <div
            class="threads-list"
            id="threadsList"
            role="list"
            aria-label="Thread list"
          >
            <div class="threads-empty" id="threadsEmptyState">
              No threads yet. Create one to get started.
            </div>
          </div>
        </aside>

        <div class="main-area" role="main">
          <nav class="view-tabs" role="tablist" aria-label="View selection">
            <button
              class="view-tab active"
              data-view-target="viewChat"
              role="tab"
              aria-selected="true"
              aria-controls="viewChat"
            >
              Chat &amp; Todos
            </button>
            <button
              class="view-tab"
              data-view-target="viewGraph"
              role="tab"
              aria-selected="false"
              aria-controls="viewGraph"
            >
              Graph
            </button>
            <button
              class="view-tab"
              data-view-target="viewFiles"
              role="tab"
              aria-selected="false"
              aria-controls="viewFiles"
            >
              Files
            </button>
          </nav>

          <div
            id="viewChat"
            class="view-section active"
            role="tabpanel"
            aria-labelledby="viewChat"
          >
            <div class="view-chat-main">
              <section class="card chat-card" aria-label="Chat interface">
                <div class="chat-header">
                  <div class="input-group">
                    <label for="threadId">Thread ID</label>
                    <input
                      id="threadId"
                      placeholder="Select or create a threadâ€¦"
                      aria-label="Thread ID input"
                    />
                  </div>
                </div>

                <div
                  class="run-summary"
                  role="status"
                  aria-live="polite"
                  aria-atomic="true"
                >
                  <span class="run-badge" id="runStatusBadge">Idle</span>
                  <span class="run-meta" id="runStep"></span>
                  <span class="run-meta" id="runModel"></span>
                </div>

                <div
                  class="chat-transcript"
                  id="chatTranscript"
                  role="log"
                  aria-label="Chat messages"
                  aria-live="polite"
                >
                  <div class="chat-empty" id="chatEmptyState">
                    Select a thread from the sidebar or create a new one to
                    start chatting.
                  </div>
                </div>

                <div class="chat-input">
                  <textarea
                    id="msg"
                    rows="3"
                    placeholder="Type a user messageâ€¦"
                    aria-label="Message input"
                  ></textarea>
                  <button
                    id="btnSend"
                    class="primary"
                    aria-label="Send message"
                  >
                    Send
                  </button>
                </div>

                <div class="chat-actions">
                  <div
                    class="button-group"
                    id="hitlButtons"
                    style="display: none"
                    role="group"
                    aria-label="Human-in-the-loop actions"
                  >
                    <button id="btnApprove" aria-label="Approve tool calls">
                      Approve (HITL)
                    </button>
                    <button id="btnReject" aria-label="Reject tool calls">
                      Reject (HITL)
                    </button>
                  </div>
                  <div
                    class="button-group"
                    role="group"
                    aria-label="Run control"
                  >
                    <button
                      id="btnCancel"
                      class="danger"
                      aria-label="Cancel current run"
                    >
                      Cancel Run
                    </button>
                  </div>
                </div>

                <div class="shortcuts-hint" title="Keyboard shortcuts">
                  Press
                  <span class="shortcut" title="Send message">Ctrl+Enter</span>
                  to send,
                  <span class="shortcut" title="Create new thread">Ctrl+N</span>
                  for new thread
                </div>
              </section>

              <div class="todos-column">
                <section class="card todos-card" aria-label="Todo list">
                  <h3>Todos</h3>
                  <div
                    class="todos-summary"
                    id="todosSummary"
                    role="status"
                    aria-live="polite"
                  ></div>
                  <ul class="todo-list" id="todosList" role="list"></ul>
                </section>
              </div>
            </div>

            <section class="card state-card" aria-label="Agent state">
              <h3>State</h3>
              <pre id="state" role="log" aria-label="Current agent state"></pre>
            </section>
          </div>

          <div
            id="viewGraph"
            class="view-section"
            role="tabpanel"
            aria-labelledby="viewGraph"
          >
            <section class="card threadline-card" aria-label="Execution graph">
              <div class="threadline-header">
                <span class="badge"
                  ><span
                    class="threadline-badge-dot"
                    style="background: #60a5fa"
                  ></span
                  >Tick</span
                >
                <span class="badge"
                  ><span
                    class="threadline-badge-dot"
                    style="background: #34d399"
                  ></span
                  >Model</span
                >
                <span class="badge"
                  ><span
                    class="threadline-badge-dot"
                    style="background: #a78bfa"
                  ></span
                  >Tool</span
                >
                <span class="badge"
                  ><span
                    class="threadline-badge-dot"
                    style="background: #f472b6"
                  ></span
                  >Spawn â—‡</span
                >
                <span class="badge"
                  ><span
                    class="threadline-badge-dot"
                    style="background: #4ade80"
                  ></span
                  >Done</span
                >
                <span class="badge"
                  ><span
                    class="threadline-badge-dot"
                    style="background: #fbbf24"
                  ></span
                  >Paused</span
                >
                <span class="badge"
                  ><span
                    class="threadline-badge-dot"
                    style="background: #f87171"
                  ></span
                  >Error</span
                >
                <span
                  class="badge"
                  style="border-style: dashed; border-color: #f472b6"
                >
                  â”Š Parentâ†”Child
                </span>
                <span
                  class="badge"
                  style="margin-left: auto"
                  title="Interactive graph controls"
                  >ðŸ’¡ Drag to pan â€¢ Scroll to zoom â€¢ Double-click to focus</span
                >
              </div>
              <div class="graph-wrap">
                <div id="graph"></div>
                <div class="zoom-controls">
                  <button id="zoomOut">-</button>
                  <span class="zoom-pct" id="zoomPct">100%</span>
                  <button id="zoomIn">+</button>
                  <button id="zoomReset">Reset</button>
                  <button id="fitGraph">Fit</button>
                  <button id="exportGraph">Export PNG</button>
                </div>
              </div>
            </section>
          </div>

          <div
            id="viewFiles"
            class="view-section"
            role="tabpanel"
            aria-labelledby="viewFiles"
          >
            <section class="card files-card" aria-label="File browser">
              <h3>Files</h3>
              <div class="files-panel">
                <div class="files-list" id="filesList"></div>
                <pre
                  class="file-preview"
                ><code id="filePreview" class="code"></code></pre>
              </div>
            </section>
          </div>
        </div>
      </div>
    </div>

    <div id="modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title" id="modalTitle">Event Details</h3>
          <button class="modal-close" id="modalClose">âœ• Close</button>
        </div>
        <div class="modal-json" id="modalJson"></div>
      </div>
    </div>
    <div id="newAgencyModal" class="modal">
      <div class="modal-content" style="width: 400px">
        <div class="modal-header">
          <h3 class="modal-title">New Agency</h3>
          <button class="modal-close" id="newAgencyClose">âœ•</button>
        </div>

        <div class="form-group">
          <label for="newAgencyName">Agency Name</label>
          <input
            id="newAgencyName"
            type="text"
            placeholder="Enter agency name..."
            autocomplete="off"
          />
        </div>

        <div class="chat-actions" style="margin-top: 24px">
          <button id="btnCreateAgency" class="primary" style="width: 100%">
            Create Agency
          </button>
        </div>
      </div>
    </div>

    <div id="newThreadModal" class="modal">
      <div class="modal-content" style="width: 400px">
        <div class="modal-header">
          <h3 class="modal-title">New Agent Thread</h3>
          <button class="modal-close" id="newThreadClose">âœ•</button>
        </div>

        <div class="form-group">
          <label for="newAgentType">Select Agent Type</label>
          <select id="newAgentType" class="form-select">
            <option value="" disabled selected>Loading agents...</option>
          </select>
        </div>

        <div class="form-group">
          <label>Description</label>
          <div id="newAgentDesc" class="agent-desc-preview">
            Select an agent type to see its description.
          </div>
        </div>

        <div class="chat-actions" style="margin-top: 24px">
          <button id="btnCreateThread" class="primary" style="width: 100%">
            Create Thread
          </button>
        </div>
      </div>
    </div>

    <!-- Blueprint Management Modal -->
    <div id="blueprintsModal" class="modal">
      <div class="modal-content" style="width: 600px; max-height: 80vh">
        <div class="modal-header">
          <h3 class="modal-title">ðŸ§¬ Blueprints</h3>
          <button class="modal-close" id="blueprintsClose">âœ•</button>
        </div>

        <div style="display: flex; gap: 12px; margin-bottom: 16px">
          <button id="btnShowBlueprintList" class="primary" style="flex: 1">
            View All
          </button>
          <button id="btnShowBlueprintCreate" style="flex: 1">
            + Create New
          </button>
        </div>

        <!-- Blueprint List View -->
        <div id="blueprintListView">
          <div
            id="blueprintsList"
            style="
              max-height: 400px;
              overflow-y: auto;
              display: flex;
              flex-direction: column;
              gap: 10px;
            "
          ></div>
        </div>

        <!-- Blueprint Create View -->
        <div id="blueprintCreateView" style="display: none">
          <div class="form-group">
            <label for="bpName">Name *</label>
            <input
              id="bpName"
              type="text"
              placeholder="e.g., customer-support"
              autocomplete="off"
            />
          </div>

          <div class="form-group">
            <label for="bpDescription">Description</label>
            <input
              id="bpDescription"
              type="text"
              placeholder="Brief description of this agent type"
              autocomplete="off"
            />
          </div>

          <div class="form-group">
            <label for="bpPrompt">System Prompt *</label>
            <textarea
              id="bpPrompt"
              rows="6"
              placeholder="You are a helpful assistant..."
              style="font-family: monospace; font-size: 12px"
            ></textarea>
          </div>

          <div class="form-group">
            <label for="bpModel">Model</label>
            <select id="bpModel" class="form-select">
              <option value="">Default (from env)</option>
              <option value="gpt-4o">gpt-4o</option>
              <option value="gpt-4o-mini">gpt-4o-mini</option>
              <option value="gpt-4-turbo">gpt-4-turbo</option>
              <option value="claude-sonnet-4-20250514">
                claude-sonnet-4-20250514
              </option>
              <option value="claude-3-5-sonnet-20241022">
                claude-3-5-sonnet
              </option>
              <option value="claude-3-5-haiku-20241022">
                claude-3-5-haiku
              </option>
            </select>
          </div>

          <div class="form-group">
            <label for="bpTags">Tags (comma-separated)</label>
            <input
              id="bpTags"
              type="text"
              placeholder="default, support"
              autocomplete="off"
            />
            <div style="font-size: 11px; color: var(--muted); margin-top: 4px">
              Include "default" tag to make this the default agent type
            </div>
          </div>

          <div class="form-group">
            <label for="bpStatus">Status</label>
            <select id="bpStatus" class="form-select">
              <option value="active">Active</option>
              <option value="draft">Draft</option>
              <option value="disabled">Disabled</option>
            </select>
          </div>

          <div class="chat-actions" style="margin-top: 24px">
            <button id="btnSaveBlueprint" class="primary" style="width: 100%">
              Save Blueprint
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Initialize Cytoscape instance (will be created later)
      let cy = null;

      // Initialize Day.js with relativeTime plugin
      if (typeof dayjs !== "undefined" && dayjs.extend) {
        dayjs.extend(window.dayjs_plugin_relativeTime);
      }

      // Initialize Notyf for notifications
      const notyf =
        typeof Notyf !== "undefined"
          ? new Notyf({
              duration: 3000,
              position: { x: "right", y: "bottom" },
              dismissible: true,
              ripple: true
            })
          : null;

      // Initialize markdown-it for rich text rendering
      const md =
        typeof window.markdownit !== "undefined"
          ? window.markdownit({
              html: false,
              linkify: true,
              breaks: true,
              highlight: function (str, lang) {
                if (
                  lang &&
                  typeof Prism !== "undefined" &&
                  Prism.languages[lang]
                ) {
                  try {
                    return Prism.highlight(str, Prism.languages[lang], lang);
                  } catch (e) {
                    console.warn("Prism highlight failed:", e);
                  }
                }
                return "";
              }
            })
          : null;

      // Initialize ky HTTP client with retry and timeout
      const http =
        typeof ky !== "undefined"
          ? ky.create({
              timeout: 30000,
              retry: {
                limit: 2,
                methods: ["get", "post"],
                statusCodes: [408, 413, 429, 500, 502, 503, 504]
              },
              hooks: {
                beforeError: [
                  (error) => {
                    const { response } = error;
                    if (response && response.body) {
                      error.name = "HTTPError";
                      error.message = `${response.status} ${response.statusText}`;
                    }
                    return error;
                  }
                ]
              }
            })
          : null;

      const $ = (id) => document.getElementById(id);
      const S = $("state");
      const G = $("graph");
      const modal = $("modal");
      const modalTitle = $("modalTitle");
      const modalJson = $("modalJson");
      const modalClose = $("modalClose");
      const connectionStatus = $("connectionStatus");
      const threadsListEl = $("threadsList");
      const runStatusBadge = $("runStatusBadge");
      const runStepLabel = $("runStep");
      const runModelLabel = $("runModel");
      const chatTranscript = $("chatTranscript");
      const threadInput = $("threadId");
      const viewTabs = Array.from(document.querySelectorAll(".view-tab"));
      const viewSections = new Map(
        Array.from(document.querySelectorAll(".view-section")).map(
          (section) => [section.id, section]
        )
      );
      const newAgencyModal = $("newAgencyModal");
      const newAgencyClose = $("newAgencyClose");
      const newAgencyName = $("newAgencyName");
      const btnCreateAgency = $("btnCreateAgency");
      const newThreadModal = $("newThreadModal");
      const newThreadClose = $("newThreadClose");
      const newAgentTypeSelect = $("newAgentType");
      const newAgentDesc = $("newAgentDesc");
      const btnCreateThread = $("btnCreateThread");

      for (const btn of viewTabs) {
        btn.addEventListener("click", () => {
          const target = btn.getAttribute("data-view-target");
          if (!target || !viewSections.has(target)) return;
          for (const other of viewTabs) {
            const isActive = other === btn;
            other.classList.toggle("active", isActive);
            other.setAttribute("aria-selected", String(isActive));
          }
          for (const [id, section] of viewSections) {
            section.classList.toggle("active", id === target);
          }
        });
      }

      // Constants
      const REFRESH_DEBOUNCE_MS = 220;
      const REFRESH_PRIORITY_MS = 40;
      const NOTIFICATION_DURATION_MS = 3000;
      const NOTIFICATION_FADE_MS = 300;
      const MAX_CHARS_PER_LINE = 32;
      const MIN_LABEL_WIDTH = 160;
      const LABEL_HEIGHT = 50;
      const LABEL_PADDING = 24;
      const LABEL_GUIDE_OFFSET = 20;

      // Centralized State Manager (easier to migrate to Zustand/React later)
      const AppState = {
        // Connection state
        mainThreadId: "",
        ws: null,
        selectedThreadId: "",

        // Thread state
        latestThreads: [],
        extraThreads: new Map(),
        expandedThreads: new Set(),

        // Agency state
        agencies: [],
        currentAgencyId: null,
        availableAgents: [],

        // UI state
        stateRefreshTimer: null,
        stateRefreshInFlight: false,

        // Getters for backward compatibility
        get mainThread() {
          return this.mainThreadId;
        },
        set mainThread(val) {
          this.mainThreadId = val;
        },

        get currentAgency() {
          return this.currentAgencyId;
        },
        set currentAgency(val) {
          this.currentAgencyId = val;
        },

        // Helper methods
        reset() {
          this.mainThreadId = "";
          this.ws = null;
          this.selectedThreadId = "";
          this.extraThreads.clear();
          this.expandedThreads.clear();
        }
      };

      // Map old state references to AppState
      const state = AppState;

      // Create local references for backward compatibility (will be removed during React migration)
      let mainThreadId = AppState.mainThreadId;
      let ws = AppState.ws;
      let selectedThreadId = AppState.selectedThreadId;
      let latestThreads = AppState.latestThreads;
      let extraThreads = AppState.extraThreads;
      let expandedThreads = AppState.expandedThreads;
      let stateRefreshTimer = AppState.stateRefreshTimer;
      let stateRefreshInFlight = AppState.stateRefreshInFlight;
      let availableAgents = AppState.availableAgents;

      async function init() {
        // Setup listeners that aren't already set up
        const agencySelect = $("agencySelect");
        const btnNewAgency = $("btnNewAgency");

        if (agencySelect) {
          agencySelect.addEventListener("change", (e) =>
            selectAgency(e.target.value)
          );
        }
        if (btnNewAgency) {
          btnNewAgency.addEventListener("click", createAgency);
        }
        if (newAgencyClose) {
          newAgencyClose.onclick = () =>
            newAgencyModal.classList.remove("open");
        }
        if (btnCreateAgency) {
          btnCreateAgency.onclick = handleCreateAgency;
        }
        if (newAgencyName) {
          newAgencyName.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              handleCreateAgency();
            }
            if (e.key === "Escape") {
              newAgencyModal.classList.remove("open");
            }
          });
        }

        await loadAgencies();
      }

      async function loadAgencies() {
        try {
          const data = http
            ? await http.get("/agencies").json()
            : await fetch("/agencies").then((r) => r.json());
          state.agencies = data.agencies || [];
          renderAgencySelect();
          if (state.agencies.length > 0) {
            selectAgency(state.agencies[0].id);
          }
        } catch (e) {
          console.error("Failed to load agencies", e);
        }
      }

      function renderAgencySelect() {
        const sel = $("agencySelect");
        if (!sel) return;
        sel.innerHTML =
          '<option value="" disabled selected>Select Agency...</option>';
        state.agencies.forEach((a) => {
          const opt = document.createElement("option");
          opt.value = a.id;
          opt.textContent = a.name;
          sel.appendChild(opt);
        });
        if (state.currentAgencyId) sel.value = state.currentAgencyId;
      }

      async function createAgency() {
        newAgencyModal.classList.add("open");
        newAgencyName.value = "";
        newAgencyName.focus();
      }

      async function handleCreateAgency() {
        const name = newAgencyName.value.trim();
        if (!name) {
          showNotification("Please enter an agency name", "error");
          return;
        }

        try {
          btnCreateAgency.textContent = "Creating...";
          btnCreateAgency.disabled = true;

          const meta = http
            ? await http.post("/agencies", { json: { name } }).json()
            : await fetch("/agencies", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ name })
              }).then(async (res) => {
                if (!res.ok) {
                  const errorText = await res.text();
                  throw new Error(errorText || "Failed to create agency");
                }
                return res.json();
              });
          newAgencyModal.classList.remove("open");
          showNotification(`Agency "${name}" created`, "success");
          await loadAgencies();
          selectAgency(meta.id);
        } catch (e) {
          showNotification("Failed to create agency: " + e.message, "error");
        } finally {
          btnCreateAgency.textContent = "Create Agency";
          btnCreateAgency.disabled = false;
        }
      }

      async function selectAgency(id) {
        state.currentAgencyId = id;
        const sel = $("agencySelect");
        if (sel) sel.value = id;

        state.currentThreadId = null;
        selectedThreadId = null;

        // Clear UI
        const list = $("threadsList");
        if (list) list.innerHTML = "";
        const chat = $("chatTranscript");
        if (chat) chat.innerHTML = "";

        // Load threads for this agency
        await loadThreads();
        // Load blueprints for this agency
        await loadAgentDefinitions();
      }

      function updateAgentPreview() {
        const name = newAgentTypeSelect.value;
        const agent = availableAgents.find((a) => a.name === name);
        newAgentDesc.textContent = agent
          ? agent.description
          : "No description available.";
      }

      async function loadAgentDefinitions() {
        if (!state.currentAgencyId) return;
        try {
          const data = http
            ? await http
                .get(`/agency/${state.currentAgencyId}/blueprints`)
                .json()
            : await fetch(`/agency/${state.currentAgencyId}/blueprints`).then(
                (r) => r.json()
              );
          availableAgents = data.blueprints || [];

          // Populate dropdown
          newAgentTypeSelect.innerHTML = "";
          availableAgents.forEach((agent) => {
            const opt = document.createElement("option");
            opt.value = agent.name;
            opt.textContent = agent.name;
            newAgentTypeSelect.appendChild(opt);
          });

          // Select first by default and update desc
          if (availableAgents.length > 0) {
            newAgentTypeSelect.value = availableAgents[0].name;
            updateAgentPreview();
          }
        } catch (e) {
          console.error("Failed to load agent defs", e);
          newAgentTypeSelect.innerHTML = "<option>Failed to load</option>";
        }
      }

      async function loadThreads(selectId = null) {
        if (!state.currentAgencyId) return;
        try {
          const list = $("threadsList");
          if (list && latestThreads.length === 0) {
            list.innerHTML =
              '<div class="threads-empty">Loading threads...</div>';
          }

          const data = http
            ? await http.get(`/agency/${state.currentAgencyId}/agents`).json()
            : await fetch(`/agency/${state.currentAgencyId}/agents`).then((r) =>
                r.json()
              );
          latestThreads = data.agents || [];
          renderThreadList(latestThreads, selectId || selectedThreadId);
        } catch (e) {
          console.error("Failed to load threads", e);
          const list = $("threadsList");
          if (list) {
            list.innerHTML =
              '<div class="threads-empty">Failed to load threads</div>';
          }
        }
      }

      newAgentTypeSelect.onchange = updateAgentPreview;

      // Fix: Use correct ID
      $("btnNewThread").onclick = () => {
        if (!state.currentAgencyId) {
          showNotification("Select an agency first", "error");
          return;
        }
        newThreadModal.classList.add("open");
        if (availableAgents.length === 0) loadAgentDefinitions();
      };

      // 5. Close handlers
      newThreadClose.onclick = () => newThreadModal.classList.remove("open");

      // 6. The Actual Create Logic
      btnCreateThread.onclick = async () => {
        const agentType = newAgentTypeSelect.value;
        if (!agentType) return;

        try {
          // Visual feedback
          btnCreateThread.textContent = "Creating...";
          btnCreateThread.disabled = true;

          const json = http
            ? await http
                .post(`/agency/${state.currentAgencyId}/agents`, {
                  json: { agentType }
                })
                .json()
            : await fetch(`/agency/${state.currentAgencyId}/agents`, {
                method: "POST",
                headers: { "content-type": "application/json" },
                body: JSON.stringify({ agentType })
              }).then(async (res) => {
                if (!res.ok) throw new Error(await res.text());
                return res.json();
              });

          // Success: Close modal, notify, load
          newThreadModal.classList.remove("open");
          showNotification(`New ${agentType} thread created`, "success");
          await loadThreads(json.id);
          await selectThread(json.id);
        } catch (error) {
          console.error("Failed to create:", error);
          showNotification(error.message, "error");
        } finally {
          btnCreateThread.textContent = "Create Thread";
          btnCreateThread.disabled = false;
        }
      };

      // --- Blueprint Management ---
      const blueprintsModal = $("blueprintsModal");
      const blueprintsClose = $("blueprintsClose");
      const blueprintListView = $("blueprintListView");
      const blueprintCreateView = $("blueprintCreateView");
      const blueprintsList = $("blueprintsList");

      $("btnBlueprints").onclick = () => {
        if (!state.currentAgencyId) {
          showNotification("Select an agency first", "error");
          return;
        }
        blueprintsModal.classList.add("open");
        showBlueprintList();
        loadBlueprintsForModal();
      };

      blueprintsClose.onclick = () => blueprintsModal.classList.remove("open");

      $("btnShowBlueprintList").onclick = () => showBlueprintList();
      $("btnShowBlueprintCreate").onclick = () => showBlueprintCreate();

      function showBlueprintList() {
        blueprintListView.style.display = "block";
        blueprintCreateView.style.display = "none";
        $("btnShowBlueprintList").classList.add("primary");
        $("btnShowBlueprintCreate").classList.remove("primary");
      }

      function showBlueprintCreate() {
        blueprintListView.style.display = "none";
        blueprintCreateView.style.display = "block";
        $("btnShowBlueprintList").classList.remove("primary");
        $("btnShowBlueprintCreate").classList.add("primary");
        // Clear form
        $("bpName").value = "";
        $("bpDescription").value = "";
        $("bpPrompt").value = "";
        $("bpModel").value = "";
        $("bpTags").value = "";
        $("bpStatus").value = "active";
      }

      async function loadBlueprintsForModal() {
        blueprintsList.innerHTML =
          '<div style="text-align: center; color: var(--muted);">Loading...</div>';
        try {
          const data = http
            ? await http
                .get(`/agency/${state.currentAgencyId}/blueprints`)
                .json()
            : await fetch(`/agency/${state.currentAgencyId}/blueprints`).then(
                (r) => r.json()
              );

          const blueprints = data.blueprints || [];
          if (blueprints.length === 0) {
            blueprintsList.innerHTML =
              '<div style="text-align: center; color: var(--muted); padding: 20px;">No blueprints found. Create one to get started.</div>';
            return;
          }

          blueprintsList.innerHTML = "";
          blueprints.forEach((bp) => {
            const card = document.createElement("div");
            card.className = "blueprint-card";
            card.style.cssText = `
              background: rgba(255,255,255,0.03);
              border: 1px dashed var(--border);
              border-radius: 8px;
              padding: 14px;
            `;

            const isDefault = bp.tags?.includes("default");
            const statusColor =
              bp.status === "active"
                ? "#4ade80"
                : bp.status === "draft"
                  ? "#fbbf24"
                  : "#94a3b8";

            card.innerHTML = `
              <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                <div>
                  <strong style="font-size: 14px;">${escapeHtml(bp.name)}</strong>
                  ${isDefault ? '<span style="margin-left: 8px; font-size: 10px; background: var(--accent); color: #000; padding: 2px 6px; border-radius: 4px;">DEFAULT</span>' : ""}
                </div>
                <span style="font-size: 11px; color: ${statusColor}; text-transform: uppercase;">${bp.status || "active"}</span>
              </div>
              <div style="font-size: 12px; color: var(--muted); margin-bottom: 8px;">${escapeHtml(bp.description || "No description")}</div>
              <div style="font-size: 11px; color: var(--muted);">
                ${bp.model ? `<span style="margin-right: 12px;">Model: ${escapeHtml(bp.model)}</span>` : ""}
                ${bp.tags?.length ? `<span>Tags: ${bp.tags.map((t) => escapeHtml(t)).join(", ")}</span>` : ""}
              </div>
              ${bp.prompt ? `<div style="margin-top: 10px; font-size: 11px; font-family: monospace; color: var(--muted); max-height: 60px; overflow: hidden; text-overflow: ellipsis;">${escapeHtml(bp.prompt.slice(0, 150))}${bp.prompt.length > 150 ? "..." : ""}</div>` : ""}
            `;
            blueprintsList.appendChild(card);
          });
        } catch (e) {
          console.error("Failed to load blueprints:", e);
          blueprintsList.innerHTML =
            '<div style="text-align: center; color: var(--err);">Failed to load blueprints</div>';
        }
      }

      $("btnSaveBlueprint").onclick = async () => {
        const name = $("bpName").value.trim();
        const prompt = $("bpPrompt").value.trim();

        if (!name) {
          showNotification("Name is required", "error");
          return;
        }
        if (!prompt) {
          showNotification("System prompt is required", "error");
          return;
        }

        const tagsRaw = $("bpTags").value.trim();
        const tags = tagsRaw
          ? tagsRaw
              .split(",")
              .map((t) => t.trim())
              .filter(Boolean)
          : [];

        const blueprint = {
          name,
          description: $("bpDescription").value.trim() || undefined,
          prompt,
          model: $("bpModel").value || undefined,
          tags,
          status: $("bpStatus").value
        };

        try {
          $("btnSaveBlueprint").textContent = "Saving...";
          $("btnSaveBlueprint").disabled = true;

          if (http) {
            await http
              .post(`/agency/${state.currentAgencyId}/blueprints`, {
                json: blueprint
              })
              .json();
          } else {
            const res = await fetch(
              `/agency/${state.currentAgencyId}/blueprints`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(blueprint)
              }
            );
            if (!res.ok) throw new Error(await res.text());
          }

          showNotification(`Blueprint "${name}" saved`, "success");
          showBlueprintList();
          loadBlueprintsForModal();
          loadAgentDefinitions(); // Refresh agent type dropdown
        } catch (e) {
          console.error("Failed to save blueprint:", e);
          showNotification("Failed to save blueprint: " + e.message, "error");
        } finally {
          $("btnSaveBlueprint").textContent = "Save Blueprint";
          $("btnSaveBlueprint").disabled = false;
        }
      };

      // --- Graph state ---
      const palette = [
        "#2563eb",
        "#16a34a",
        "#9333ea",
        "#ea580c",
        "#0891b2",
        "#b91c1c",
        "#0ea5e9",
        "#059669"
      ];
      const lanes = new Map(); // threadId -> { lane, color, ws?, nodes:[] }
      const laneMeta = new Map(); // threadId -> meta info
      const laneOrder = []; // threadIds in display order
      const nodeMap = new Map(); // nodeId -> {type, threadId, data}
      const childSpawnMap = new Map(); // childId -> spawnNodeKey (in parent)
      const pendingEdges = new Map();
      const primingThreads = new Set();
      const threadCursors = new Map(); // Track node sequence per thread
      const firstNodeInLane = new Map(); // threadId -> first nodeKey
      const lastNodeInLane = new Map(); // threadId -> last nodeKey
      const lastNodePerLane = new Map(); // lane number -> nodeKey
      const lastCompletionX = new Map(); // threadId -> last child completion X position
      const childFinalX = new Map(); // childThreadId -> X position where child completed
      const childToParent = new Map(); // childId -> parentId (track parent-child relationships)
      const pendingCompletions = new Map(); // parentId -> Set of childIds waiting for completion

      // Track spawn batches - each pause creates a new batch
      const currentBatchChildren = new Map(); // parentId -> Set of childIds in current batch
      const childBatchPauseX = new Map(); // childId -> pause X position for this child's batch
      const batchLastCompletionX = new Map(); // "parentId:pauseX" -> last completion X in this batch
      const batchPendingCount = new Map(); // "parentId:pauseX" -> count of pending children
      const deferredResumed = new Map(); // "parentId:pauseX" -> deferred resumed event

      // Track parent blocking state - defer ALL events until batch completes
      const parentBlockedAtPause = new Map(); // parentId -> pauseX (which pause is blocking)
      const deferredParentEvents = new Map(); // parentId -> array of deferred events
      let layoutDebounce = null;

      function initCytoscape() {
        if (cy) {
          cy.destroy();
        }

        cy = cytoscape({
          container: G,
          style: [
            {
              selector: "node",
              style: {
                "background-color": "data(color)",
                "border-width": 3,
                "border-color": "data(borderColor)",
                label: "data(label)",
                color: "#e2e8f0",
                "text-valign": "bottom",
                "text-halign": "center",
                "text-margin-y": 8,
                "font-size": "10px",
                "font-family": "'JetBrains Mono', Consolas, monospace",
                width: "data(size)",
                height: "data(size)",
                "text-wrap": "wrap",
                "text-max-width": "90px",
                "transition-property":
                  "border-width, border-color, width, height",
                "transition-duration": "0.15s"
              }
            },
            {
              selector: 'node[type="tick"]',
              style: {
                "font-size": "9px",
                color: "#94a3b8"
              }
            },
            {
              selector: 'node[type="spawn"]',
              style: {
                shape: "diamond",
                "font-weight": "600"
              }
            },
            {
              selector: 'node[type="done"]',
              style: {
                shape: "round-rectangle",
                "font-weight": "600"
              }
            },
            {
              selector: 'node[type="error"]',
              style: {
                shape: "round-octagon"
              }
            },
            {
              selector: "node:selected",
              style: {
                "border-width": 5,
                "border-color": "#f97316",
                "overlay-opacity": 0.15,
                "overlay-color": "#f97316"
              }
            },
            {
              selector: "edge",
              style: {
                width: 2,
                "line-color": "data(color)",
                "target-arrow-color": "data(color)",
                "target-arrow-shape": "triangle",
                "curve-style": "bezier",
                "arrow-scale": 1,
                opacity: 0.7,
                "transition-property": "width, opacity",
                "transition-duration": "0.15s"
              }
            },
            {
              selector: 'edge[type="spawn"]',
              style: {
                "line-style": "dashed",
                "line-dash-pattern": [8, 4],
                "line-color": "#f472b6",
                "target-arrow-color": "#f472b6",
                width: 2.5,
                opacity: 0.9,
                "curve-style": "straight" // Straight vertical lines for spawn/completion edges
              }
            },
            {
              selector: 'edge[type="flow"]',
              style: {
                "curve-style": "straight", // Straight horizontal lines for flow edges
                opacity: 0.6
              }
            },
            {
              selector: "edge:selected",
              style: {
                width: 4,
                opacity: 1
              }
            }
          ],
          layout: {
            name: "preset"
          },
          minZoom: 0.3,
          maxZoom: 3,
          wheelSensitivity: 0.2
        });

        // Click handler for nodes
        cy.on("tap", "node", function (evt) {
          const node = evt.target;
          const data = node.data();
          openModal(data.payload, data.label, data.type);
        });

        // Double-click to focus and zoom to node
        cy.on("dbltap", "node", function (evt) {
          const node = evt.target;
          cy.animate({
            fit: {
              eles: node,
              padding: 100
            },
            duration: 500,
            easing: "ease-out"
          });
        });

        // Hover effects for nodes
        cy.on("mouseover", "node", function (evt) {
          const node = evt.target;
          node.style({
            "border-width": 5,
            "z-index": 999
          });
        });

        cy.on("mouseout", "node", function (evt) {
          const node = evt.target;
          node.style({
            "border-width": 3,
            "z-index": 1
          });
        });

        // Hover effects for edges
        cy.on("mouseover", "edge", function (evt) {
          const edge = evt.target;
          edge.style({
            width: 5,
            opacity: 1
          });
        });

        cy.on("mouseout", "edge", function (evt) {
          const edge = evt.target;
          edge.style({
            width: 3,
            opacity: 0.6
          });
        });

        // Initialize navigator (minimap)
        if (typeof cy.navigator === "function") {
          cy.navigator({
            container: false,
            viewLiveFramerate: 30,
            thumbnailEventFramerate: 30,
            thumbnailLiveFramerate: false,
            dblClickDelay: 200,
            removeCustomContainer: true,
            rerenderDelay: 100
          });
        }

        updateZoomDisplay();
      }

      function updateZoomDisplay() {
        if (cy) {
          const zp = $("zoomPct");
          if (zp) zp.textContent = Math.round(cy.zoom() * 100) + "%";
        }
      }

      initCytoscape();

      function resetGraphState() {
        closeAllSockets();
        if (cy) {
          cy.elements().remove();
        }
        lanes.clear();
        laneMeta.clear();
        laneOrder.splice(0);
        nodeMap.clear();
        childSpawnMap.clear();
        pendingEdges.clear();
        primingThreads.clear();
        threadCursors.clear();
        firstNodeInLane.clear();
        lastNodeInLane.clear();
        lastNodePerLane.clear();
        lastCompletionX.clear();
        childFinalX.clear();
        childToParent.clear();
        pendingCompletions.clear();
        currentBatchChildren.clear();
        childBatchPauseX.clear();
        batchLastCompletionX.clear();
        batchPendingCount.clear();
        deferredResumed.clear();
        parentBlockedAtPause.clear();
        deferredParentEvents.clear();
      }

      function runGraphLayout(immediate = false) {
        if (!cy) return;

        // Debounce layout to avoid too frequent updates (unless immediate)
        if (layoutDebounce) clearTimeout(layoutDebounce);

        const doLayout = () => {
          try {
            // Use preset layout to honor our manual positioning
            // This preserves the cursor-based X positions we calculated
            const layout = cy.layout({
              name: "preset",
              animate: false,
              fit: false,
              padding: 50
            });

            layout.run();
          } catch (e) {
            console.warn("Layout error:", e);
          }
        };

        if (immediate) {
          doLayout();
        } else {
          layoutDebounce = setTimeout(doLayout, 100);
        }
      }

      function scheduleStateRefresh(priority = false) {
        if (!selectedThreadId) return;
        if (primingThreads.has(selectedThreadId)) return;
        const delay = priority ? REFRESH_PRIORITY_MS : REFRESH_DEBOUNCE_MS;
        if (stateRefreshTimer) {
          if (priority) {
            clearTimeout(stateRefreshTimer);
            stateRefreshTimer = setTimeout(runPendingStateRefresh, delay);
          }
          return;
        }
        stateRefreshTimer = setTimeout(runPendingStateRefresh, delay);
      }

      async function runPendingStateRefresh() {
        stateRefreshTimer = null;
        if (!selectedThreadId) return;
        if (stateRefreshInFlight) {
          scheduleStateRefresh(true);
          return;
        }
        await refreshState();
      }

      function updateRunSummary(run, state) {
        if (!run) {
          runStatusBadge.textContent = "Idle";
          runStatusBadge.className = "run-badge";
          runStepLabel.textContent = "";
          runModelLabel.textContent = "";
          return;
        }

        const label = (run.status || "unknown").replace(/_/g, " ");
        runStatusBadge.textContent = label;
        runStatusBadge.className = `run-badge ${run.status}`;

        const parts = [];
        if (typeof run.step === "number") parts.push(`step ${run.step}`);
        if (run.reason) parts.push(`reason: ${run.reason}`);
        runStepLabel.textContent = parts.join(" â€¢ ");

        const meta = [];
        const agentType = state?.agentType ?? state?.thread?.agentType;
        if (agentType) meta.push(`Agent: ${agentType}`);
        if (state?.model) meta.push(`Model: ${state.model}`);
        runModelLabel.textContent = meta.join(" â€¢ ");

        const threadId = selectedThreadId || mainThreadId || state?.thread?.id;
        updateLaneMeta(threadId, {
          title:
            agentType || (threadId === mainThreadId ? "Root Agent" : undefined),
          agentType,
          status: run.status,
          model: state?.model,
          createdAt: state?.thread?.createdAt
        });
      }

      function resetThreadView() {
        renderChat([]);
        updateRunSummary(null, null);
        renderTodos({});
        renderFiles({});
        S.textContent = "";
        extraThreads.clear();
        if (
          selectedThreadId &&
          !latestThreads.some((t) => t.id === selectedThreadId)
        ) {
          const created = new Date().toISOString();
          extraThreads.set(selectedThreadId, {
            id: selectedThreadId,
            createdAt: created,
            isSubagent: true,
            status: "active"
          });
          updateLaneMeta(selectedThreadId, {
            status: "active",
            createdAt: created,
            isSubagent: true
          });
        }
        renderThreadList(latestThreads, selectedThreadId);
      }

      function closeAllSockets() {
        for (const lane of lanes.values()) {
          if (lane.ws) {
            try {
              // ReconnectingWebSocket compatible close
              if (typeof lane.ws.close === "function") {
                lane.ws.close(1000, "reset");
              }
            } catch (err) {
              console.warn("Failed to close lane socket", err);
            }
          }
        }
        if (ws) {
          try {
            if (typeof ws.close === "function") {
              ws.close(1000, "reset");
            }
          } catch (err) {
            console.warn("Failed to close main socket", err);
          }
        }
        mainThreadId = "";
        ws = undefined;
      }

      // Cytoscape zoom controls
      $("zoomIn").onclick = () => {
        if (cy) {
          cy.zoom(cy.zoom() * 1.2);
          cy.center();
          updateZoomDisplay();
        }
      };
      $("zoomOut").onclick = () => {
        if (cy) {
          cy.zoom(cy.zoom() / 1.2);
          cy.center();
          updateZoomDisplay();
        }
      };
      $("zoomReset").onclick = () => {
        if (cy) {
          cy.zoom(1);
          cy.center();
          updateZoomDisplay();
        }
      };
      $("fitGraph").onclick = () => {
        if (cy) {
          cy.fit(null, 50);
          updateZoomDisplay();
        }
      };
      $("exportGraph").onclick = () => {
        if (cy) {
          const png = cy.png({ full: true, scale: 2 });
          const link = document.createElement("a");
          link.download = `agent-graph-${Date.now()}.png`;
          link.href = png;
          link.click();
          showNotification("Graph exported as PNG", "success");
        }
      };

      // Update zoom display on zoom events
      if (cy) {
        cy.on("zoom", updateZoomDisplay);
      }

      function laneFor(threadId) {
        if (lanes.has(threadId)) return lanes.get(threadId).lane;
        const lane = lanes.size;
        const laneObj = {
          lane,
          color: palette[lane % palette.length],
          nodes: []
        };
        lanes.set(threadId, laneObj);
        laneOrder.push(threadId);
        return lane;
      }

      function updateLaneMeta(threadId, meta = {}) {
        if (!threadId) return;
        const current = laneMeta.get(threadId) || {};
        laneMeta.set(threadId, { ...current, ...meta });
      }

      function addNode(threadId, type, label, payload, minIdx = -1) {
        if (!cy) return null;

        const lane = laneFor(threadId);
        const laneObj = lanes.get(threadId);

        let currentCursor = threadCursors.get(threadId);
        if (currentCursor === undefined) currentCursor = -1;

        // Calculate next position
        let nextIdx;
        if (minIdx >= 0) {
          // This is a completion node - use the exact position provided
          nextIdx = minIdx;
          console.log(
            `[addNode] Placing completion node for ${short(threadId)} at X=${nextIdx} (minIdx provided, current cursor=${currentCursor})`
          );
        } else {
          // Normal sequential positioning - must advance past any jump-ahead nodes
          nextIdx = currentCursor + 1;
        }

        // Always update cursor to highest position used (to avoid overlaps)
        const newCursor = Math.max(currentCursor, nextIdx);
        threadCursors.set(threadId, newCursor);

        console.log(
          `[addNode] Adding ${type} "${label}" to ${short(threadId)} at X=${nextIdx}, Y=${lane}, cursor updated to ${newCursor}`
        );

        // Manual node positioning - preserved by preset layout
        // This ensures parent-child return nodes align horizontally
        const x = nextIdx * 150;
        const y = lane * 120;

        // Node styling by type - vibrant colors for better visual distinction
        const nodeStyles = {
          tick: { border: "#60a5fa", bg: "#1e3a5f", size: 18 },
          model: { border: "#34d399", bg: "#064e3b", size: 36 },
          tool: { border: "#a78bfa", bg: "#4c1d95", size: 32 },
          spawn: { border: "#f472b6", bg: "#831843", size: 34 },
          done: { border: "#4ade80", bg: "#14532d", size: 36 },
          paused: { border: "#fbbf24", bg: "#78350f", size: 32 },
          error: { border: "#f87171", bg: "#7f1d1d", size: 32 }
        };
        const style = nodeStyles[type] || {
          border: "#94a3b8",
          bg: "#1f2937",
          size: 32
        };
        const borderColor = style.border;
        const color = style.bg;
        const size = style.size;

        const nodeKey = `${threadId}-${payload.seq ?? Date.now()}-${nextIdx}`;

        // Add node to Cytoscape
        cy.add({
          group: "nodes",
          data: {
            id: nodeKey,
            label: label,
            type: type,
            threadId: threadId,
            color: color,
            borderColor: borderColor,
            size: size,
            payload: payload,
            lane: lane,
            index: nextIdx
          },
          position: { x, y }
        });

        // Add edge from previous node in this thread
        const prevNodes = laneObj.nodes;
        if (prevNodes.length > 0) {
          const prevKey = prevNodes[prevNodes.length - 1];
          cy.add({
            group: "edges",
            data: {
              id: `${prevKey}-${nodeKey}`,
              source: prevKey,
              target: nodeKey,
              type: "flow",
              color: "rgba(56, 189, 248, 0.4)"
            }
          });
        }

        nodeMap.set(nodeKey, { type, threadId, data: payload });
        laneObj.nodes.push(nodeKey);

        // Track first and last nodes
        if (!firstNodeInLane.has(threadId)) {
          firstNodeInLane.set(threadId, nodeKey);
        }
        lastNodeInLane.set(threadId, nodeKey);
        lastNodePerLane.set(lane, nodeKey);

        // Run layout (skip during priming for performance)
        if (!primingThreads.has(threadId)) {
          runGraphLayout();
        }

        return nodeKey;
      }

      function connectLanes(fromNodeKey, toNodeKey) {
        if (!cy) return;
        if (!fromNodeKey || !toNodeKey) return;

        // Check if both nodes exist
        const fromNode = cy.getElementById(fromNodeKey);
        const toNode = cy.getElementById(toNodeKey);

        if (fromNode.length === 0 || toNode.length === 0) {
          console.warn(
            "[connectLanes] Cannot connect - node(s) missing:",
            fromNodeKey,
            toNodeKey
          );
          return;
        }

        const fromData = fromNode.data();
        const toData = toNode.data();
        const fromIdx = fromData.index;
        const toIdx = toData.index;

        // Verify alignment - nodes should be at same X index for vertical edge
        if (fromIdx !== toIdx) {
          // Misalignment detected! Align both to the maximum position
          const alignedX = Math.max(fromIdx, toIdx);
          console.warn(
            `[connectLanes] âš ï¸ Misaligned: ${fromData.label}(X=${fromIdx}) â†’ ${toData.label}(X=${toIdx}). Aligning both to X=${alignedX}`
          );

          // Move both nodes to aligned position
          if (fromIdx !== alignedX) {
            fromNode.data("index", alignedX);
            fromNode.position({ x: alignedX * 150, y: fromNode.position().y });
          }
          if (toIdx !== alignedX) {
            toNode.data("index", alignedX);
            toNode.position({ x: alignedX * 150, y: toNode.position().y });
          }
        }

        // Add spawn/completion edge (dashed, vertical)
        const edgeId = `lane-${fromNodeKey}-${toNodeKey}`;
        if (cy.getElementById(edgeId).length === 0) {
          cy.add({
            group: "edges",
            data: {
              id: edgeId,
              source: fromNodeKey,
              target: toNodeKey,
              type: "spawn",
              color: "#f472b6"
            }
          });
        }
      }

      function flushPendingEdgesForLane(threadId) {
        if (primingThreads.has(threadId)) return;
        const pend = pendingEdges.get(threadId);
        if (!pend || !pend.length) return;
        const lastKey = lastNodeInLane.get(threadId);
        if (!lastKey) return;
        for (const parentKey of pend) connectLanes(lastKey, parentKey);
        pendingEdges.delete(threadId);
      }

      function openModal(payload, label, type) {
        modalTitle.textContent = label + " - " + type;
        const jsonString = JSON.stringify(payload, null, 2);

        // Use Prism.js for syntax highlighting
        if (typeof Prism !== "undefined") {
          const highlighted = Prism.highlight(
            jsonString,
            Prism.languages.json,
            "json"
          );
          modalJson.innerHTML = `<pre class="language-json"><code class="language-json">${highlighted}</code></pre>`;
        } else {
          modalJson.textContent = jsonString;
        }

        modal.classList.add("open");
      }

      function closeModal() {
        modal.classList.remove("open");
      }

      const REFRESH_EVENTS = new Set([
        "thread.created",
        "request.accepted",
        "run.started",
        "run.tick",
        "run.paused",
        "run.resumed",
        "run.completed",
        "run.canceled",
        "agent.started",
        "agent.completed",
        "agent.error",
        "model.started",
        "model.completed",
        "tool.started",
        "tool.output",
        "tool.error",
        "hitl.interrupt",
        "hitl.resume",
        "subagent.spawned",
        "subagent.completed",
        "checkpoint.saved"
      ]);

      const PRIORITY_REFRESH_EVENTS = new Set([
        "agent.completed",
        "agent.error",
        "run.completed",
        "run.paused",
        "run.resumed",
        "run.canceled",
        "tool.error",
        "subagent.spawned",
        "subagent.completed",
        "hitl.resume"
      ]);

      function handleEvent(threadId, ev) {
        const t = ev?.type;
        if (!t) return;
        const isPriming = primingThreads.has(threadId);

        // Check if this parent is blocked waiting for children
        // Only defer parent events, not child completion notifications
        if (parentBlockedAtPause.has(threadId)) {
          const blockedPauseX = parentBlockedAtPause.get(threadId);
          // Only allow subagent.completed (child completion notifications) through
          // Parent's own agent.completed should be deferred!
          if (t !== "subagent.completed") {
            // Defer this event until batch completes
            if (!deferredParentEvents.has(threadId)) {
              deferredParentEvents.set(threadId, []);
            }
            deferredParentEvents.get(threadId).push(ev);
            console.log(
              `[handleEvent] Deferring ${t} for blocked parent ${short(threadId)} (pauseX=${blockedPauseX})`
            );
            return;
          }
        }

        // Map event to node
        switch (t) {
          case "run.tick": {
            updateLaneMeta(threadId, { status: "running" });
            addNode(threadId, "tick", `tick #${ev.data?.step ?? "?"}`, ev);
            break;
          }
          case "model.started": {
            const modelName = ev.data?.model ?? "";
            updateLaneMeta(threadId, { status: "running", model: modelName });
            addNode(threadId, "model", `model: ${modelName}`, ev);
            break;
          }
          case "tool.output": {
            const name = ev.data?.toolName ?? "tool";
            addNode(threadId, "tool", `${name} âœ“`, ev);
            break;
          }
          case "tool.error": {
            const name = ev.data?.toolName ?? "tool";
            updateLaneMeta(threadId, { status: "error" });
            addNode(threadId, "error", `${name} âœ—`, ev);
            break;
          }
          case "run.paused": {
            const r = ev.data?.reason ?? "paused";
            updateLaneMeta(threadId, { status: "paused" });
            addNode(threadId, "paused", `paused (${r})`, ev);

            // Track if paused waiting for subagents
            if (r === "subagent" || r === "subagents") {
              const pauseX = threadCursors.get(threadId) || 0;
              const currentBatch = currentBatchChildren.get(threadId);

              if (currentBatch && currentBatch.size > 0) {
                // Associate this pause position with all children in current batch
                const batchKey = `${threadId}:${pauseX}`;
                let pendingCount = 0;

                for (const childId of currentBatch) {
                  childBatchPauseX.set(childId, pauseX);
                  pendingCount++;
                }

                batchPendingCount.set(batchKey, pendingCount);

                // BLOCK this parent until all children in this batch complete
                parentBlockedAtPause.set(threadId, pauseX);

                console.log(
                  `[run.paused] Parent ${short(threadId)} BLOCKED at X=${pauseX} with ${pendingCount} children in batch`
                );

                // Clear current batch for next spawn cycle
                currentBatchChildren.set(threadId, new Set());
              }
            }
            break;
          }
          case "run.resumed": {
            updateLaneMeta(threadId, { status: "running" });
            // Note: If parent is blocked, this event was already deferred by handleEvent()
            // If we get here, we can add the node
            addNode(threadId, "tick", "resumed", ev);
            break;
          }
          case "agent.completed": {
            updateLaneMeta(threadId, { status: "completed" });
            const completionKey = addNode(threadId, "done", "done âœ“", ev);

            if (completionKey) {
              lastNodeInLane.set(threadId, completionKey);
            }

            const finalX = threadCursors.get(threadId) || 0;
            childFinalX.set(threadId, finalX);
            console.log(
              `[agent.completed] Thread ${short(threadId)} completed at X=${finalX}`
            );

            // If this thread is a child, create parent's completion node
            const parentId = childToParent.get(threadId);
            if (parentId && completionKey) {
              console.log(
                `[agent.completed] Creating parent completion for ${short(parentId)} <- child ${short(threadId)}`
              );

              // Remove from pending
              const pending = pendingCompletions.get(parentId);
              if (pending) pending.delete(threadId);

              // Get this child's BATCH-SPECIFIC pause position
              const pauseX = childBatchPauseX.get(threadId);
              const batchKey =
                pauseX !== undefined ? `${parentId}:${pauseX}` : null;

              // Get batch-specific last completion position
              const lastCompletion = batchKey
                ? batchLastCompletionX.get(batchKey) || -1
                : lastCompletionX.get(parentId) || -1;

              // Target position is where the child naturally completed
              // BUT if that conflicts with a previous completion, shift right
              let targetX = finalX;

              // Minimum X is after previous completions in this batch
              const minX = lastCompletion + 1;
              if (targetX <= lastCompletion) {
                targetX = minX;
                console.log(
                  `[agent.completed] Collision: child at X=${finalX}, last completion at X=${lastCompletion}. Shifting to X=${targetX}`
                );

                // Move child's done node to new position
                if (cy) {
                  const childDoneNode = cy.getElementById(completionKey);
                  if (childDoneNode.length > 0) {
                    childDoneNode.data("index", targetX);
                    childDoneNode.position({
                      x: targetX * 150,
                      y: childDoneNode.position().y
                    });
                    threadCursors.set(threadId, targetX);
                    childFinalX.set(threadId, targetX);
                  }
                }
              }

              console.log(
                `[agent.completed] Child done at X=${finalX}, completion at X=${targetX}`
              );

              // Track completion position for this batch
              if (batchKey) {
                batchLastCompletionX.set(batchKey, targetX);
              }
              lastCompletionX.set(parentId, targetX);

              // Update parent cursor to be after this completion
              threadCursors.set(
                parentId,
                Math.max(threadCursors.get(parentId) || 0, targetX)
              );

              // Create parent's completion node at child's done position
              const parentCompletionKey = addNode(
                parentId,
                "done",
                `â† ${short(threadId)}`,
                { ...ev, childThreadId: threadId },
                targetX
              );

              console.log(
                `[agent.completed] Parent ${short(parentId)} completion at X=${targetX}`
              );

              if (parentCompletionKey) {
                connectLanes(completionKey, parentCompletionKey);
              }

              // Decrement batch pending count and check if complete
              if (batchKey) {
                const remaining = (batchPendingCount.get(batchKey) || 1) - 1;
                batchPendingCount.set(batchKey, remaining);

                if (remaining === 0) {
                  console.log(
                    `[agent.completed] Batch ${batchKey} complete, unblocking parent`
                  );

                  // Unblock the parent
                  parentBlockedAtPause.delete(parentId);

                  // Process deferred events in order
                  const deferred = deferredParentEvents.get(parentId) || [];
                  deferredParentEvents.delete(parentId);

                  console.log(
                    `[agent.completed] Processing ${deferred.length} deferred events for ${short(parentId)}`
                  );

                  for (const deferredEv of deferred) {
                    handleEvent(parentId, deferredEv);
                  }
                }
              }
            }
            break;
          }
          case "agent.error": {
            updateLaneMeta(threadId, { status: "error" });
            addNode(threadId, "error", "error", ev);
            break;
          }
          case "subagent.spawned": {
            const childId = ev.data?.childThreadId;
            const agentType = ev.data?.agentType || "";
            const spawnLabel = agentType
              ? `â†’ ${agentType}`
              : `â†’ ${short(childId)}`;

            const spawnKey = addNode(threadId, "spawn", spawnLabel, ev);

            // Get parent cursor AFTER spawn node was added
            const parentCursor = threadCursors.get(threadId);

            if (childId) {
              // Child starts at (parentCursor - 1) so its first node aligns with spawn
              threadCursors.set(childId, (parentCursor || 0) - 1);
              console.log(
                `[subagent.spawned] Parent ${short(threadId)} at X=${parentCursor}, child ${short(childId)} cursor set to ${(parentCursor || 0) - 1}`
              );
              connectThreadWS(childId);

              // Track parent-child relationship
              childToParent.set(childId, threadId);

              // Track pending completions
              if (!pendingCompletions.has(threadId)) {
                pendingCompletions.set(threadId, new Set());
              }
              pendingCompletions.get(threadId).add(childId);

              // Add to current batch (will be finalized when pause happens)
              if (!currentBatchChildren.has(threadId)) {
                currentBatchChildren.set(threadId, new Set());
              }
              currentBatchChildren.get(threadId).add(childId);
            }

            updateLaneMeta(childId, {
              status: "spawning",
              isSubagent: true,
              agentType
            });
            childSpawnMap.set(childId, spawnKey);
            break;
          }
          case "subagent.completed": {
            const child = ev.data?.childThreadId;

            if (!child) {
              console.error(
                `[subagent.completed] Missing childThreadId in event:`,
                ev
              );
              break;
            }

            // Check if already handled by agent.completed
            const pending = pendingCompletions.get(threadId);
            if (pending && !pending.has(child)) {
              console.log(
                `[subagent.completed] Child ${short(child)} already completed, skipping`
              );
              break;
            }

            updateLaneMeta(child, { status: "completed" });

            const childLastKey = lastNodeInLane.get(child);
            if (!childLastKey) {
              console.warn(
                `[subagent.completed] Child ${short(child)} has no nodes, skipping`
              );
              break;
            }

            if (pending) pending.delete(child);

            // Get child's done position
            let childEndX = childFinalX.get(child);
            let childLastNode = null;

            if (cy) {
              childLastNode = cy.getElementById(childLastKey);
              if (childLastNode.length > 0) {
                const idx = childLastNode.data("index");
                if (typeof idx === "number") childEndX = idx;
              }
            }
            if (childEndX === undefined) {
              childEndX = threadCursors.get(child) || 0;
            }

            // Use BATCH-SPECIFIC tracking
            const pauseX = childBatchPauseX.get(child);
            const batchKey =
              pauseX !== undefined ? `${threadId}:${pauseX}` : null;
            const lastCompletion = batchKey
              ? batchLastCompletionX.get(batchKey) || -1
              : lastCompletionX.get(threadId) || -1;

            // Target is where child naturally completed, unless collision
            let targetX = childEndX;
            if (targetX <= lastCompletion) {
              targetX = lastCompletion + 1;
              console.log(
                `[subagent.completed] Collision: child at X=${childEndX}, shifting to X=${targetX}`
              );

              if (childLastNode && childLastNode.length > 0) {
                childLastNode.data("index", targetX);
                childLastNode.position({
                  x: targetX * 150,
                  y: childLastNode.position().y
                });
                threadCursors.set(child, targetX);
                childFinalX.set(child, targetX);
              }
            }

            console.log(
              `[subagent.completed] Child done at X=${childEndX}, completion at X=${targetX}`
            );

            if (batchKey) batchLastCompletionX.set(batchKey, targetX);
            lastCompletionX.set(threadId, targetX);
            threadCursors.set(
              threadId,
              Math.max(threadCursors.get(threadId) || 0, targetX)
            );

            const completionKey = addNode(
              threadId,
              "done",
              `â† ${short(child)}`,
              ev,
              targetX
            );

            console.log(
              `[subagent.completed] Parent ${short(threadId)}: completion at X=${targetX}`
            );

            if (childLastKey && !primingThreads.has(child)) {
              connectLanes(childLastKey, completionKey);
            } else {
              const pendingList = pendingEdges.get(child) || [];
              pendingList.push(completionKey);
              pendingEdges.set(child, pendingList);
            }

            // Decrement batch pending count and check if complete
            if (batchKey) {
              const remaining = (batchPendingCount.get(batchKey) || 1) - 1;
              batchPendingCount.set(batchKey, remaining);

              if (remaining === 0) {
                console.log(
                  `[subagent.completed] Batch ${batchKey} complete, unblocking parent`
                );

                // Unblock the parent
                parentBlockedAtPause.delete(threadId);

                // Process deferred events
                const deferred = deferredParentEvents.get(threadId) || [];
                deferredParentEvents.delete(threadId);

                console.log(
                  `[subagent.completed] Processing ${deferred.length} deferred events`
                );

                for (const deferredEv of deferred) {
                  handleEvent(threadId, deferredEv);
                }
              }
            }
            break;
          }
          default:
            if (t === "checkpoint.saved") {
              // Checkpoint indicator - we could add a badge to the last node
              // For now, just log it
              console.log("Checkpoint saved for thread:", threadId);
            }
        }

        // Connect spawn node to child's first node (should be vertical)
        const firstKey = firstNodeInLane.get(threadId);
        if (firstKey && childSpawnMap.has(threadId)) {
          const spawnKey = childSpawnMap.get(threadId);

          // Verify alignment before connecting
          if (cy) {
            const spawnNode = cy.getElementById(spawnKey);
            const firstNode = cy.getElementById(firstKey);
            if (spawnNode.length > 0 && firstNode.length > 0) {
              const spawnX = spawnNode.data("index");
              const firstX = firstNode.data("index");
              if (spawnX !== firstX) {
                // Misalignment detected - adjust child's first node to match spawn
                console.log(
                  `[spawnâ†’child] Adjusting child first node from X=${firstX} to X=${spawnX} to align with spawn`
                );
                const oldY = firstNode.position().y;
                firstNode.data("index", spawnX);
                firstNode.position({ x: spawnX * 150, y: oldY });
              }
            }
          }

          connectLanes(spawnKey, firstKey);
          childSpawnMap.delete(threadId);
        }

        flushPendingEdgesForLane(threadId);

        if (
          !isPriming &&
          threadId === selectedThreadId &&
          REFRESH_EVENTS.has(t)
        ) {
          scheduleStateRefresh(PRIORITY_REFRESH_EVENTS.has(t));
        }
      }

      function short(id) {
        return (id || "").slice(0, 6);
      }

      // --- Notification system ---
      function showNotification(message, type = "info") {
        // Use Notyf if available
        if (notyf) {
          try {
            if (type === "success") {
              notyf.success(message);
            } else if (type === "error") {
              notyf.error(message);
            } else {
              // Notyf doesn't have built-in "info", so use success with custom styling
              notyf.open({
                type: "info",
                message: message,
                background: "#60a5fa",
                icon: false
              });
            }
            return;
          } catch (e) {
            console.warn("Notyf notification failed, using fallback:", e);
          }
        }

        // Fallback to custom notification
        const notification = document.createElement("div");
        notification.className = `notification ${type}`;
        notification.textContent = message;

        document.body.appendChild(notification);

        setTimeout(() => {
          notification.style.opacity = "0";
          setTimeout(() => notification.remove(), NOTIFICATION_FADE_MS);
        }, NOTIFICATION_DURATION_MS);
      }

      // --- Connection status ---
      function updateConnectionStatus(connected) {
        const status = connectionStatus;
        status.className = `status-indicator ${connected ? "connected" : "disconnected"}`;
        status.querySelector("span:last-child").textContent = connected
          ? "Connected"
          : "Disconnected";
      }

      async function connect(idOverride) {
        const id = (idOverride ?? $("threadId").value ?? "").trim();
        if (!id) {
          showNotification("Please enter a thread ID", "error");
          return;
        }
        // Basic validation: thread IDs should be non-empty strings
        if (typeof id !== "string" || id.length === 0) {
          showNotification("Invalid thread ID", "error");
          return;
        }

        try {
          const switching = id !== mainThreadId;
          selectedThreadId = id;
          if (threadInput) threadInput.value = id;
          if (switching) {
            resetGraphState();
            resetThreadView();
            // Show loading state
            const chat = $("chatTranscript");
            if (chat) {
              chat.innerHTML =
                '<div class="chat-empty">Connecting to thread...</div>';
            }
          }
          mainThreadId = id;
          renderThreadList(latestThreads, id);
          await primeEventsDeep(id);
          showNotification("Connected to thread", "success");
          await refreshState(true);
          await loadThreads(id);
        } catch (error) {
          console.error("Connection error:", error);
          showNotification("Failed to connect: " + error.message, "error");
          const chat = $("chatTranscript");
          if (chat) {
            chat.innerHTML =
              '<div class="chat-empty">Failed to connect. Please try again.</div>';
          }
        }
      }

      async function fetchEventsForThread(threadId) {
        if (!state.currentAgencyId) return [];
        try {
          const j = http
            ? await http
                .get(
                  `/agency/${state.currentAgencyId}/agent/${threadId}/events`
                )
                .json()
            : await fetch(
                `/agency/${state.currentAgencyId}/agent/${threadId}/events`
              ).then((r) => r.json());
          return j.events || [];
        } catch (err) {
          console.error(`Failed to fetch events for ${threadId}:`, err);
          return [];
        }
      }

      async function primeEventsDeep(rootId) {
        try {
          // Step 1: Discover all threads by following spawn events
          console.log(
            `[primeEventsDeep] Discovering threads starting from ${short(rootId)}`
          );
          const visited = new Set();
          const q = [rootId];
          const allThreadIds = [];

          while (q.length) {
            const id = q.shift();
            if (visited.has(id)) continue;
            visited.add(id);
            allThreadIds.push(id);

            // Fetch events to find children
            const events = await fetchEventsForThread(id);
            for (const ev of events) {
              if (
                ev?.type === "subagent.spawned" ||
                ev?.type === "subagent.completed"
              ) {
                const cid = ev?.data?.childThreadId;
                if (cid && !visited.has(cid)) {
                  q.push(cid);
                }
              }
            }
          }

          console.log(
            `[primeEventsDeep] Found ${allThreadIds.length} threads:`,
            allThreadIds.map(short)
          );

          // Step 2: Fetch ALL events from ALL threads
          const allEventsWithThread = [];
          for (const threadId of allThreadIds) {
            const events = await fetchEventsForThread(threadId);
            events.forEach((ev) => {
              allEventsWithThread.push({ threadId, ev });
            });
          }

          console.log(
            `[primeEventsDeep] Fetched ${allEventsWithThread.length} total events`
          );

          // Step 3: Sort ALL events by timestamp with dependency-aware secondary sort
          // This ensures agent.completed for a child comes BEFORE subagent.completed for parent
          allEventsWithThread.sort((a, b) => {
            const timeA = new Date(a.ev.timestamp || 0).getTime();
            const timeB = new Date(b.ev.timestamp || 0).getTime();

            // Primary sort by timestamp
            if (timeA !== timeB) return timeA - timeB;

            // Secondary sort: ensure correct dependency order for same-timestamp events
            const aType = a.ev?.type || "";
            const bType = b.ev?.type || "";

            // agent.completed must come before subagent.completed that references it
            if (aType === "agent.completed" && bType === "subagent.completed") {
              const childId = b.ev?.data?.childThreadId;
              if (childId === a.threadId) {
                return -1; // a (agent.completed) comes first
              }
            }
            if (bType === "agent.completed" && aType === "subagent.completed") {
              const childId = a.ev?.data?.childThreadId;
              if (childId === b.threadId) {
                return 1; // b (agent.completed) comes first
              }
            }

            // subagent.spawned must come before child's first event
            if (aType === "subagent.spawned") {
              const childId = a.ev?.data?.childThreadId;
              if (childId === b.threadId) {
                return -1; // spawn comes before child's events
              }
            }
            if (bType === "subagent.spawned") {
              const childId = b.ev?.data?.childThreadId;
              if (childId === a.threadId) {
                return 1; // spawn comes before child's events
              }
            }

            return 0;
          });

          console.log(
            `[primeEventsDeep] Processing in TWO passes: pre-compute then render`
          );

          // Step 4: PRE-PASS - Set up parent-child relationships only
          // Batch tracking happens during main pass when we know X positions
          console.log(
            `[primeEventsDeep] Pre-pass: Setting up parent-child relationships`
          );

          allEventsWithThread.forEach(({ threadId, ev }) => {
            if (ev?.type === "subagent.spawned") {
              const childId = ev.data?.childThreadId;
              if (childId) {
                // Track parent-child relationship
                childToParent.set(childId, threadId);
                if (!pendingCompletions.has(threadId)) {
                  pendingCompletions.set(threadId, new Set());
                }
                pendingCompletions.get(threadId).add(childId);
              }
            }
          });

          console.log(
            `[primeEventsDeep] Pre-pass complete. Found ${childToParent.size} parent-child relationships`
          );

          // Step 5: Mark all threads as priming
          allThreadIds.forEach((id) => primingThreads.add(id));

          // Step 6: MAIN PASS - Process all events in chronological order (with pre-computed data)
          console.log(
            `[primeEventsDeep] Main pass: Processing ${allEventsWithThread.length} events in order`
          );
          allEventsWithThread.forEach(({ threadId, ev }) => {
            handleEvent(threadId, ev);
          });

          // Step 7: Flush pending edges and cleanup
          allThreadIds.forEach((id) => {
            primingThreads.delete(id);
            flushPendingEdgesForLane(id);
            connectThreadWS(id); // Connect websockets for live updates
          });

          // Run final layout once after all threads are primed
          runGraphLayout(true);

          console.log(`[primeEventsDeep] Priming complete`);
        } catch (err) {
          console.error("Failed to prime events:", err);
          showNotification("Failed to load thread events", "error");
        }
      }

      // ...

      function connectThreadWS(threadId) {
        if (!state.currentAgencyId) return;
        if (lanes.has(threadId) && lanes.get(threadId).ws) return; // already connected
        laneFor(threadId);
        const proto = location.protocol === "https:" ? "wss" : "ws";
        const url = `${proto}://${location.host}/agency/${state.currentAgencyId}/agent/${threadId}/ws`;

        // Use ReconnectingWebSocket for automatic reconnection
        const socket = new ReconnectingWebSocket(url, [], {
          maxRetries: 10,
          maxReconnectionDelay: 10000,
          minReconnectionDelay: 1000,
          reconnectionDelayGrowFactor: 1.3,
          connectionTimeout: 4000,
          debug: false
        });

        lanes.get(threadId).ws = socket;
        if (threadId === mainThreadId) ws = socket;

        socket.addEventListener("open", () => {
          console.log(`[ws] ${threadId} connected`);
          updateLaneMeta(threadId, { status: "listening" });
          if (threadId === mainThreadId) {
            updateConnectionStatus(true);
            showNotification("WebSocket connected", "success");
          }
        });

        socket.addEventListener("close", () => {
          console.log(`[ws] ${threadId} closed`);
          updateLaneMeta(threadId, { status: "offline" });
          if (threadId === mainThreadId) {
            updateConnectionStatus(false);
          }
        });

        socket.addEventListener("error", (error) => {
          console.error(`[ws] ${threadId} error:`, error);
          if (threadId === mainThreadId) {
            showNotification("WebSocket connection error", "error");
          }
        });

        socket.addEventListener("message", (m) => {
          try {
            const ev = JSON.parse(m.data);
            const tid = ev.threadId || threadId;
            handleEvent(tid, ev);
          } catch (err) {
            console.error("WS message error:", err, m.data);
          }
        });
      }

      async function send() {
        if (!state.currentAgencyId) {
          showNotification("Please select an agency first", "error");
          return;
        }
        const id = $("threadId").value.trim();
        const content = $("msg").value.trim();
        if (!id) {
          showNotification("Please enter a thread ID", "error");
          return;
        }
        if (!content) {
          showNotification("Please enter a message", "error");
          return;
        }

        const btnSend = $("btnSend");
        const originalText = btnSend.textContent;
        try {
          btnSend.textContent = "Sending...";
          btnSend.disabled = true;

          if (http) {
            await http.post(
              `/agency/${state.currentAgencyId}/agent/${id}/invoke`,
              {
                json: { messages: [{ role: "user", content }] }
              }
            );
          } else {
            await fetch(`/agency/${state.currentAgencyId}/agent/${id}/invoke`, {
              method: "POST",
              headers: { "content-type": "application/json" },
              body: JSON.stringify({ messages: [{ role: "user", content }] })
            });
          }
          $("msg").value = "";
          showNotification("Message sent", "success");
          await refreshState(true);
        } catch (error) {
          console.error("Failed to send message:", error);
          showNotification("Failed to send message: " + error.message, "error");
        } finally {
          btnSend.textContent = originalText;
          btnSend.disabled = false;
        }
      }

      async function hitl(approved) {
        if (!state.currentAgencyId) return;
        const id = $("threadId").value.trim();
        if (!id) {
          showNotification("No thread selected", "error");
          return;
        }

        try {
          if (http) {
            await http.post(
              `/agency/${state.currentAgencyId}/agent/${id}/approve`,
              {
                json: { approved, modifiedToolCalls: [] }
              }
            );
          } else {
            await fetch(
              `/agency/${state.currentAgencyId}/agent/${id}/approve`,
              {
                method: "POST",
                headers: { "content-type": "application/json" },
                body: JSON.stringify({ approved, modifiedToolCalls: [] })
              }
            );
          }
          showNotification(
            (approved ? "Approved" : "Rejected") + " HITL request",
            "success"
          );
          await refreshState(true);
        } catch (error) {
          console.error("Failed to send HITL response:", error);
          showNotification(
            "Failed to send HITL response: " + error.message,
            "error"
          );
        }
      }

      async function cancelRun() {
        if (!state.currentAgencyId) return;
        const id = $("threadId").value.trim();
        if (!id) {
          showNotification("No thread selected", "error");
          return;
        }

        // Confirmation dialog
        if (
          !confirm(
            "Are you sure you want to cancel the current run? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          if (http) {
            await http.post(
              `/agency/${state.currentAgencyId}/agent/${id}/cancel`
            );
          } else {
            await fetch(`/agency/${state.currentAgencyId}/agent/${id}/cancel`, {
              method: "POST"
            });
          }
          showNotification("Run cancelled", "success");
          await refreshState(true);
        } catch (error) {
          console.error("Failed to cancel run:", error);
          showNotification("Failed to cancel run: " + error.message, "error");
        }
      }

      async function refreshState(force = false) {
        if (!state.currentAgencyId) return;
        if (stateRefreshInFlight && !force) return;
        if (stateRefreshTimer) {
          clearTimeout(stateRefreshTimer);
          stateRefreshTimer = null;
        }
        const id = (selectedThreadId || threadInput?.value || "").trim();
        if (!id) return;
        if (stateRefreshInFlight && force) {
          scheduleStateRefresh(true);
          return;
        }

        stateRefreshInFlight = true;
        try {
          const j = http
            ? await http
                .get(`/agency/${state.currentAgencyId}/agent/${id}/state`)
                .json()
            : await fetch(
                `/agency/${state.currentAgencyId}/agent/${id}/state`
              ).then((r) => r.json());
          S.textContent = JSON.stringify(j, null, 2);
          const threadState = j.state ?? {};
          renderChat(threadState.messages ?? []);
          renderTodos(threadState);
          renderFiles(threadState);
          updateRunSummary(j.run, threadState);
          renderSubagents(threadState.subagents ?? []);

          // Show/hide HITL buttons based on pending tool calls
          const hitlButtons = $("hitlButtons");
          const hasPendingToolCalls =
            (threadState.pendingToolCalls?.length ?? 0) > 0;
          if (hitlButtons) {
            hitlButtons.style.display = hasPendingToolCalls ? "flex" : "none";
          }
        } catch (err) {
          console.error("Failed to refresh state:", err);
          showNotification("Failed to refresh state: " + err.message, "error");
        } finally {
          stateRefreshInFlight = false;
        }
      }

      // Modal controls
      modalClose.onclick = closeModal;
      modal.onclick = (e) => {
        if (e.target === modal) closeModal();
      };
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") closeModal();

        // Ctrl/Cmd + Enter to send message
        if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
          e.preventDefault();
          send();
        }

        // Ctrl/Cmd + N for new thread
        if ((e.ctrlKey || e.metaKey) && e.key === "n") {
          e.preventDefault();
          if (!state.currentAgencyId) {
            showNotification("Select an agency first", "error");
            return;
          }
          newThreadModal.classList.add("open");
          if (availableAgents.length === 0) loadAgentDefinitions();
        }

        // Graph navigation shortcuts (when graph view is active)
        const graphView = document.getElementById("viewGraph");
        if (graphView && graphView.classList.contains("active") && cy) {
          // Ctrl/Cmd + F to fit graph
          if ((e.ctrlKey || e.metaKey) && e.key === "f") {
            e.preventDefault();
            cy.fit(null, 50);
            updateZoomDisplay();
          }

          // Ctrl/Cmd + 0 to reset zoom
          if ((e.ctrlKey || e.metaKey) && e.key === "0") {
            e.preventDefault();
            cy.zoom(1);
            cy.center();
            updateZoomDisplay();
          }

          // Ctrl/Cmd + Plus to zoom in
          if ((e.ctrlKey || e.metaKey) && (e.key === "+" || e.key === "=")) {
            e.preventDefault();
            cy.zoom(cy.zoom() * 1.2);
            cy.center();
            updateZoomDisplay();
          }

          // Ctrl/Cmd + Minus to zoom out
          if ((e.ctrlKey || e.metaKey) && e.key === "-") {
            e.preventDefault();
            cy.zoom(cy.zoom() / 1.2);
            cy.center();
            updateZoomDisplay();
          }
        }
      });

      // Button handlers
      $("btnSend").onclick = send;
      $("btnApprove").onclick = () => hitl(true);
      $("btnReject").onclick = () => hitl(false);
      $("btnCancel").onclick = cancelRun;
      if (threadInput) {
        threadInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            const value = threadInput.value.trim();
            if (value) selectThread(value);
          }
        });
      }

      // Initial load - wait for agency selection
      resetThreadView();

      // Thread & chat helpers
      function formatRelativeTime(iso) {
        if (!iso) return "";

        // Use Day.js if available
        if (typeof dayjs !== "undefined") {
          try {
            return dayjs(iso).fromNow();
          } catch (e) {
            console.warn("Day.js formatting failed:", e);
          }
        }

        // Fallback to manual implementation
        const ts = Date.parse(iso);
        if (Number.isNaN(ts)) return iso;
        const diff = Date.now() - ts;
        const abs = Math.abs(diff);
        const minute = 60_000;
        const hour = 60 * minute;
        const day = 24 * hour;
        if (abs < minute) return "just now";
        if (abs < hour) return `${Math.round(abs / minute)}m ago`;
        if (abs < day) return `${Math.round(abs / hour)}h ago`;
        return new Date(ts).toLocaleString();
      }

      async function selectThread(id, { connectThread = true } = {}) {
        if (!id || typeof id !== "string") {
          showNotification("Invalid thread ID", "error");
          return;
        }
        selectedThreadId = id;
        if (threadInput) threadInput.value = id;
        renderThreadList(latestThreads, id);
        if (connectThread) {
          await connect(id);
        } else {
          await refreshState(true);
        }
      }

      function renderSubagents(subagents = []) {
        extraThreads.clear();

        if (Array.isArray(subagents)) {
          for (const link of subagents) {
            if (!link?.childThreadId) continue;
            const childId = link.childThreadId;
            const createdAtIso = new Date(
              link.createdAt ?? Date.now()
            ).toISOString();
            extraThreads.set(childId, {
              id: childId,
              createdAt: createdAtIso,
              status: link.status,
              parent: { threadId: selectedThreadId },
              report: link.report,
              agentType: link.agentType,
              isSubagent: true
            });
            updateLaneMeta(childId, {
              title: link.agentName || link.agentType || "Subagent",
              agentName: link.agentName,
              agentType: link.agentType,
              status: link.status,
              createdAt: createdAtIso,
              isSubagent: true,
              report: link.report
            });
          }
        }

        if (
          selectedThreadId &&
          !latestThreads.some((t) => t.id === selectedThreadId) &&
          !extraThreads.has(selectedThreadId)
        ) {
          const created = new Date().toISOString();
          extraThreads.set(selectedThreadId, {
            id: selectedThreadId,
            createdAt: created,
            isSubagent: true,
            status: "active"
          });
          updateLaneMeta(selectedThreadId, {
            status: "active",
            createdAt: created,
            isSubagent: true
          });
        }

        renderThreadList(latestThreads, selectedThreadId);
      }

      function renderChat(messages = []) {
        chatTranscript.innerHTML = "";
        if (!messages.length) {
          const empty = document.createElement("div");
          empty.className = "chat-empty";
          empty.id = "chatEmptyState";
          empty.textContent = selectedThreadId
            ? "No messages yet. Type a message below to start the conversation."
            : "Select a thread to load the conversation.";
          chatTranscript.appendChild(empty);
          return;
        }

        const buildToolCall = (titleText, bodyText) => {
          const wrapper = document.createElement("div");
          wrapper.className = "tool-call collapsed";

          const header = document.createElement("div");
          header.className = "tool-call-header";

          const heading = document.createElement("span");
          heading.className = "tool-call-title";
          heading.textContent = titleText;
          header.appendChild(heading);

          const toggle = document.createElement("button");
          toggle.type = "button";
          toggle.className = "tool-call-toggle";
          header.appendChild(toggle);

          wrapper.appendChild(header);

          const body = document.createElement("pre");
          body.className = "tool-call-body";
          body.textContent = bodyText;
          wrapper.appendChild(body);

          const updateToggle = () => {
            const collapsed = wrapper.classList.contains("collapsed");
            toggle.textContent = collapsed ? "Show output" : "Hide output";
            toggle.setAttribute("aria-expanded", String(!collapsed));
          };

          updateToggle();
          toggle.addEventListener("click", () => {
            wrapper.classList.toggle("collapsed");
            updateToggle();
          });

          return wrapper;
        };

        for (const msg of messages) {
          const role = msg.role;
          const bubble = document.createElement("div");
          bubble.className = "chat-message " + role;

          const roleLabel = document.createElement("div");
          roleLabel.className = "chat-role";
          roleLabel.textContent = role.toUpperCase();
          bubble.appendChild(roleLabel);

          const content = document.createElement("div");
          content.className = "chat-content";

          if (role === "assistant" && msg.toolCalls?.length) {
            if (msg.content) {
              const text = document.createElement("div");
              text.textContent = msg.content;
              content.appendChild(text);
            }
            for (const call of msg.toolCalls) {
              const title = call.name || "tool";
              const body = JSON.stringify(call.args ?? {}, null, 2);
              content.appendChild(buildToolCall(title, body));
            }
          } else if (role === "tool") {
            const title = msg.toolName || msg.name || "Tool output";
            const body =
              typeof msg.content === "string"
                ? msg.content
                : JSON.stringify(msg.content ?? "", null, 2);
            content.appendChild(buildToolCall(title, body));
          } else {
            // Use markdown rendering if available
            const msgContent = msg.content ?? "";
            if (md && msgContent) {
              try {
                content.innerHTML = md.render(msgContent);
              } catch (e) {
                console.warn("Markdown rendering failed, using plain text:", e);
                content.textContent = msgContent;
              }
            } else {
              content.textContent = msgContent;
            }
          }

          bubble.appendChild(content);
          chatTranscript.appendChild(bubble);
        }

        chatTranscript.scrollTop = chatTranscript.scrollHeight;
      }

      function renderThreadList(threads = [], activeId) {
        const combined = new Map();
        for (const meta of threads ?? [])
          if (meta?.id) combined.set(meta.id, { ...meta, source: "root" });
        for (const meta of extraThreads.values())
          if (meta?.id && !combined.has(meta.id))
            combined.set(meta.id, { ...meta });

        const nodeMap = new Map();
        for (const meta of combined.values()) {
          updateLaneMeta(meta.id, {
            title:
              meta.agentName ||
              meta.agentType ||
              (meta.isSubagent ? "Subagent" : "Agent"),
            agentName: meta.agentName,
            agentType: meta.agentType,
            status: meta.status,
            createdAt: meta.createdAt,
            isSubagent: meta.isSubagent
          });
          nodeMap.set(meta.id, { meta: { ...meta }, children: [] });
        }
        for (const n of nodeMap.values()) {
          const pid = n.meta.parent?.threadId;
          if (pid && nodeMap.has(pid)) nodeMap.get(pid).children.push(n);
        }
        const roots = [];
        for (const n of nodeMap.values()) {
          const pid = n.meta.parent?.threadId;
          if (!pid || !nodeMap.has(pid)) roots.push(n);
        }

        const cmp = (a, b) => {
          const ta = Date.parse(a.meta.createdAt ?? ""),
            tb = Date.parse(b.meta.createdAt ?? "");
          if (Number.isNaN(ta) && Number.isNaN(tb)) return 0;
          if (Number.isNaN(ta)) return 1;
          if (Number.isNaN(tb)) return -1;
          return tb - ta;
        };
        const sortBranch = (arr) => {
          arr.sort(cmp);
          for (const n of arr) if (n.children.length) sortBranch(n.children);
        };
        sortBranch(roots);

        if (activeId && nodeMap.has(activeId)) {
          let p = nodeMap.get(activeId).meta.parent?.threadId;
          while (p) {
            expandedThreads.add(p);
            p = nodeMap.get(p)?.meta.parent?.threadId;
          }
        }

        threadsListEl.innerHTML = "";
        if (!nodeMap.size) {
          const emptyMsg = state.currentAgencyId
            ? "No threads yet. Click 'New' to create a thread."
            : "Select an agency to view threads.";
          threadsListEl.innerHTML = `<div class="threads-empty">${emptyMsg}</div>`;
          return;
        }

        const frag = document.createDocumentFragment();

        const buildRow = (node, depth) => {
          const { meta, children } = node;
          const isActive = meta.id === activeId;
          const hasChildren = children.length > 0;
          const expanded = expandedThreads.has(meta.id);

          const row = document.createElement("div");
          row.className = "thread-row" + (expanded ? " expanded" : "");

          const btn = document.createElement("button");
          btn.type = "button";
          btn.className =
            "thread-item" +
            (isActive ? " active" : "") +
            (hasChildren ? " has-children" : "");
          btn.dataset.depth = String(depth);
          btn.style.setProperty("--depth", String(depth));
          btn.setAttribute(
            "aria-label",
            `Thread ${short8(meta.id)}${isActive ? ", currently selected" : ""}`
          );
          if (hasChildren) {
            btn.setAttribute("aria-expanded", String(expanded));
          }

          const titleWrap = document.createElement("div");
          titleWrap.className = "thread-title";

          // caret / spacer
          const caret = document.createElement("span");
          caret.className = "thread-caret";
          caret.textContent = hasChildren ? (expanded ? "â–¾" : "â–¸") : " ";
          if (hasChildren) {
            caret.setAttribute("role", "button");
            caret.setAttribute(
              "aria-label",
              expanded ? "Collapse thread" : "Expand thread"
            );
            caret.setAttribute("tabindex", "0");
            caret.title = expanded ? "Collapse" : "Expand";
            caret.onclick = (e) => {
              e.stopPropagation();
              if (expanded) expandedThreads.delete(meta.id);
              else expandedThreads.add(meta.id);
              renderThreadList(latestThreads, activeId ?? selectedThreadId);
            };
            caret.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                e.stopPropagation();
                if (expanded) expandedThreads.delete(meta.id);
                else expandedThreads.add(meta.id);
                renderThreadList(latestThreads, activeId ?? selectedThreadId);
              }
            });
          }
          titleWrap.appendChild(caret);

          // 8-char id
          const idShort = document.createElement("span");
          idShort.className = "thread-id-short";
          idShort.textContent = short8(meta.id);
          titleWrap.appendChild(idShort);

          // status pill (no "Status:" text)
          if (meta.status) {
            const pill = document.createElement("span");
            pill.className = "status-pill " + statusClass(meta.status);
            pill.textContent = statusLabel(meta.status);
            titleWrap.appendChild(pill);
          }

          btn.appendChild(titleWrap);

          // tiny time only (keep it sparse)
          const metaWrap = document.createElement("div");
          metaWrap.className = "thread-meta";
          const t = formatTinyTime(meta.createdAt);
          metaWrap.textContent = t ? t : "";
          btn.appendChild(metaWrap);

          // Tooltip: full, crowded info â€” but NO report
          const tooltip = [
            `ID: ${meta.id}`,
            meta.parent?.threadId
              ? `Parent: ${meta.parent.threadId}`
              : "Root thread",
            meta.agentName ? `Name: ${meta.agentName}` : null,
            meta.agentType ? `Agent: ${meta.agentType}` : null,
            meta.status ? `Status: ${statusLabel(meta.status)}` : null,
            meta.createdAt
              ? `Created: ${new Date(meta.createdAt).toLocaleString()}`
              : null,
            meta.request?.cf?.city ? `City: ${meta.request.cf.city}` : null,
            meta.request?.userAgent ? `UA: ${meta.request.userAgent}` : null
          ].filter(Boolean);
          btn.title = tooltip.join("\n"); // intentionally excluding meta.report

          btn.onclick = () => selectThread(meta.id);

          row.appendChild(btn);

          if (hasChildren) {
            const childWrap = document.createElement("div");
            childWrap.className = "thread-children";
            childWrap.style.display = expanded ? "block" : "none";
            for (const c of children)
              childWrap.appendChild(buildRow(c, depth + 1));
            row.appendChild(childWrap);
          }

          return row;
        };

        for (const n of roots) frag.appendChild(buildRow(n, 0));
        threadsListEl.appendChild(frag);
      }

      // ---- Todos ----

      function renderTodos(state) {
        const todos = state?.todos || [];
        const wrap = document.getElementById("todosList");
        const summary = document.getElementById("todosSummary");
        wrap.innerHTML = "";
        summary.innerHTML = "";

        if (!todos.length) {
          summary.innerHTML = `<span class="todo-pill">No todos yet</span>`;
          return;
        }

        const counts = { pending: 0, in_progress: 0, completed: 0 };
        todos.forEach((t) => {
          counts[t.status] = (counts[t.status] || 0) + 1;
        });

        summary.innerHTML = `
        <span class="todo-pill pending">Pending: ${counts.pending || 0}</span>
        <span class="todo-pill in_progress">In progress: ${counts.in_progress || 0}</span>
        <span class="todo-pill completed">Completed: ${counts.completed || 0}</span>
        <span class="todo-pill">Total: ${todos.length}</span>
      `;

        for (const t of todos) {
          const li = document.createElement("li");
          li.className = "todo-item";
          li.innerHTML = `
          <span class="todo-status ${t.status}"></span>
          <div class="todo-content">
            <div>${escapeHtml(t.content || "")}</div>
            <div style="margin-top:6px; font-size:12px; color:var(--muted);">Status: ${t.status}</div>
          </div>
        `;
          wrap.appendChild(li);
        }
      }

      // ---- Files ----
      let _selectedFile = null;

      function renderFiles(state) {
        const files = state?.files || {};
        const list = document.getElementById("filesList");
        const preview = document.getElementById("filePreview");
        list.innerHTML = "";
        preview.textContent = "";

        const paths = Object.keys(files).sort();
        if (!paths.length) {
          list.innerHTML = `<div class="file-row"><span class="file-name">(no files)</span></div>`;
          return;
        }

        for (const p of paths) {
          const content = files[p] ?? "";
          const size = new TextEncoder().encode(content).length; // bytes
          const lines = content ? content.split(/\r?\n/).length : 0;

          const row = document.createElement("div");
          row.className = "file-row";
          row.onclick = () => selectFile(p, content);
          row.innerHTML = `
          <span class="file-name" title="${escapeHtml(p)}">${escapeHtml(p)}</span>
          <span class="file-meta">${lines} lines â€¢ ${size} B</span>
        `;
          list.appendChild(row);
        }

        // keep previous selection if still present
        if (_selectedFile && files[_selectedFile] !== undefined) {
          selectFile(_selectedFile, files[_selectedFile]);
        } else {
          // auto-select first
          const first = paths[0];
          selectFile(first, files[first]);
        }
      }

      function selectFile(path, content) {
        _selectedFile = path;
        const code = document.getElementById("filePreview");
        const ext = path.split(".").pop()?.toLowerCase();

        // Render markdown files with markdown-it
        if (ext === "md" && md && content) {
          try {
            code.innerHTML = md.render(content);
            code.style.padding = "20px";
            code.style.lineHeight = "1.6";
          } catch (e) {
            console.warn(
              "Markdown rendering failed, using syntax highlighting:",
              e
            );
            code.innerHTML = renderWithLineNumbers(content, path);
            code.style.padding = "";
            code.style.lineHeight = "";
          }
        } else {
          code.innerHTML = renderWithLineNumbers(content || "", path);
          code.style.padding = "";
          code.style.lineHeight = "";
        }
      }

      // helpers
      function renderWithLineNumbers(text, filename = "") {
        const lines = (text ?? "").split(/\r?\n/);

        // Detect language from file extension for Prism.js
        const ext = filename.split(".").pop()?.toLowerCase();
        const langMap = {
          js: "javascript",
          ts: "typescript",
          json: "json",
          py: "python",
          md: "markdown",
          html: "html",
          css: "css",
          tsx: "typescript",
          jsx: "javascript"
        };
        const lang = langMap[ext] || "javascript";

        // Try to use Prism for syntax highlighting
        if (typeof Prism !== "undefined" && Prism.languages[lang]) {
          try {
            const highlighted = Prism.highlight(
              text,
              Prism.languages[lang],
              lang
            );
            const highlightedLines = highlighted.split(/\r?\n/);
            return highlightedLines
              .map((line, i) => {
                const ln = String(i + 1).padStart(4, " ");
                return `<span class="ln">${ln}</span>${line}\n`;
              })
              .join("");
          } catch (e) {
            console.warn(
              "Prism highlighting failed, falling back to plain text:",
              e
            );
          }
        }

        // Fallback to escaped HTML
        return lines
          .map((line, i) => {
            const ln = String(i + 1).padStart(4, " ");
            return `<span class="ln">${ln}</span>${escapeHtml(line)}\n`;
          })
          .join("");
      }

      function escapeHtml(s) {
        return String(s)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }
      function short8(id) {
        return (id || "").slice(0, 8);
      }

      function formatTinyTime(iso) {
        if (!iso) return "";

        // Use Day.js if available
        if (typeof dayjs !== "undefined") {
          try {
            const date = dayjs(iso);
            const diffHours = Math.abs(date.diff(dayjs(), "hour"));

            if (diffHours < 1) return date.fromNow();
            if (diffHours < 24) return date.fromNow();
            return date.format("MMM D");
          } catch (e) {
            console.warn("Day.js formatting failed:", e);
          }
        }

        // Fallback to manual implementation
        const ts = Date.parse(iso);
        if (Number.isNaN(ts)) return "";
        const diff = Date.now() - ts;
        const m = 60_000,
          h = 60 * m,
          d = 24 * h;
        if (Math.abs(diff) < m) return "Just now";
        if (Math.abs(diff) < h) return Math.round(Math.abs(diff) / m) + "m ago";
        if (Math.abs(diff) < d) return Math.round(Math.abs(diff) / h) + "h ago";
        return new Date(ts).toLocaleDateString();
      }

      function statusClass(s) {
        return (
          "s-" +
          String(s || "")
            .toLowerCase()
            .replace(/\s+/g, "_")
        );
      }

      function statusLabel(s) {
        return String(s || "").replace(/_/g, " ");
      }
      init();
    </script>
  </body>
</html>
